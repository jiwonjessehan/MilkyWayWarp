import numpy as npimport healpy as hpimport pandas as pdimport cmasher as cmrimport tqdmimport pickleimport itertoolsfrom copy import copyimport seaborn as snsimport gala.dynamics as gdimport gala.potential as gpfrom gala.units import galacticfrom gala.potential import scffrom matplotlib import cmfrom matplotlib import pyplot as pltfrom matplotlib import colors as clrfrom matplotlib.gridspec import GridSpecfrom matplotlib.colors import LinearSegmentedColormapfrom matplotlib.animation import FuncAnimation, PillowWriter# from mpl_toolkits.axes_grid.inset_locator import (inset_axes, InsetPosition,#                                                   mark_inset)from astropy.io import fitsfrom astropy import units as ufrom astropy import coordinates as coordfrom astropy.table import Tablefrom astropy.coordinates import Angleimport scipy.signal as signalfrom scipy.optimize import curve_fitfrom scipy.stats import exponfrom scipy.interpolate import interp1dfrom scipy.spatial.transform import Rotation as Rotfrom scipy.stats import truncexponfrom scipy.signal import medfiltfrom multiprocessing import Poolfrom multiprocessing import cpu_countNCPU = cpu_count()coord.galactocentric_frame_defaults.set('v4.0')import matplotlib as mplimport matplotlib.font_manager as font_managerfe = font_manager.FontEntry(    fname="/Users/jhan/anaconda3/envs/science/lib/python3.8/site-packages/matplotlib/mpl-data/fonts/ttf/",    name='Minion PRo')font_manager.fontManager.ttflist.insert(0, fe) # or append is finempl.rcParams['font.family'] = fe.name # = 'your custom ttf font name'#%%from astropy.cosmology import WMAP9 as cosmoplt.figure(dpi=300)for z in np.linspace(0,10,100):    pm_res = 13*u.uas/u.year    dist_per_ang = cosmo.kpc_proper_per_arcmin(z=z)    speed= (dist_per_ang*pm_res).to(u.km/u.s)    dist = cosmo.luminosity_distance(z=z)    plt.scatter(dist,speed,c='k',s=1)plt.xlabel('Luminosity Distance (Mpc)')plt.ylabel('Velocity Resolution [km/s]')plt.show()#%%def in_box(x,y,z): # Select particles only in a reasonable box around the galactic center    box = 100    donut = 0 # Optionally, select a donut (to avoid messy <1kpc structure)    box_cut = ( (np.abs(x)<box) & (np.abs(y)<box) & (np.abs(z)<box) )    donut_cut = ~( (np.abs(x)<donut) & (np.abs(y)<donut) & (np.abs(z)<donut) )    dcut = box_cut #& donut_cut    return dcutdef sim_DarkMatter():    downsample_factor = 0.05 # There are way too many particles to all fit!    with fits.open('/Users/jhan/Science/H3/potential_paper/GSE_DM.fits') as hdul:        GSEpresent = Table(hdul[1].data)        GSEpresent.rename_column('X_gal', 'X')        GSEpresent.rename_column('Y_gal', 'Y')        GSEpresent.rename_column('Z_gal', 'Z')        downsample = np.random.choice([False,True],p=[1-downsample_factor,downsample_factor],size=len(GSEpresent))        GSEpresent = GSEpresent[downsample]        box_bool = in_box(GSEpresent['X'], GSEpresent['Y'], GSEpresent['Z'])        GSEpresent = GSEpresent[box_bool]        xs, ys, zs = GSEpresent['X'], GSEpresent['Y'], GSEpresent['Z']        GSE_particles = np.vstack([xs, ys, zs]).T        return GSE_particlesdef return_scf_coeffs(particles):    r_s = 18.    S,T = scf.compute_coeffs_discrete(np.array(particles,dtype=np.double), mass=np.ones(len(particles)) / len(particles), r_s=r_s,                                                    nmax=10, lmax=4, skip_m=False,skip_odd=True,                                                    compute_var=False)    # signal_to_noise = np.sqrt(S**2 / varS)    # plt.figure(dpi=250,figsize=(7,7))    # for l in range(S.shape[1]):    #     plt.semilogy(signal_to_noise[:,l,0], marker=None, lw=2,    #                   alpha=0.5, label='l={}'.format(l))        # plt.axhline(1., linestyle='dashed')    # plt.xlabel("$n$")    # plt.ylabel("$S/N$")    # plt.legend()    return S,T# S,T = return_scf_coeffs(sim_DarkMatter())#%%# track_fig = plt.figure(dpi=300,figsize=(4,4))# track_ax = plt.gca()def evolving_potential(dt, nstep, R_GSE, tilt_angle=None, mass_frac=None):    # Four component:        # Bulge (static), Halo (static), thick (static), thin (time varying)    # assert nstep>1000, "Nstep must be > 1000"        thin_masses = 3.5e10*np.linspace(3/8,8/8,nstep)    # halo_masses = (5.4e11 + 6e10) - thin_masses    if mass_frac == None:        final_gsefrac = 0.3    else:        final_gsefrac = mass_frac    # gse_fracs = np.zeros(nstep)    # gse_fracs[:int(1000/dt)] = np.linspace(0, final_gsefrac, int(1000/dt)) # Spend the first Gyr growing    # gse_fracs[int(1000/dt): ] = final_gsefrac    if R_GSE==0:        final_gsefrac = 0.000001        R_GSE = 10000    gse_fracs = final_gsefrac*np.ones(nstep)        halo_masses = 5.4e11 * np.ones(nstep)        if tilt_angle == None:        pitch_i, yaw_i = -25.39, 0 #- 60 #+ 90        pitch_f, yaw_f = -25.39, 0 #- 60 #+ 90    else:        pitch_i, yaw_i = -tilt_angle, 0 #- 60 #+ 90        pitch_f, yaw_f = -tilt_angle, 0 #- 60 #+ 90        pitchlist = np.linspace(pitch_i,pitch_f,nstep)    yawlist = np.linspace(yaw_i,yaw_f,nstep)    pot_list = []        for t in range(nstep):        gse_rot = Rot.from_euler('yz', [pitchlist[t], yawlist[t]], degrees=True)        # track_ax.scatter(pitchlist[t], yawlist[t],s=1,c='k')        bulge = dict(m=1.84e10 * u.Msun, c=1.0 * u.kpc, units=galactic)        thick = dict(m=6e9 * u.Msun, a=2.0 * u.kpc, b= 0.9 * u.kpc, units=galactic)        thin = dict(m=thin_masses[t]*u.Msun, a=2.6 * u.kpc, b= 0.3 * u.kpc, units=galactic)        mw_halo = dict(m=halo_masses[t] * u.Msun, r_s = 15 * u.kpc, units=galactic)        gse_halo = dict(m=halo_masses[t] * u.Msun * gse_fracs[t]/(1-gse_fracs[t]), r_s= R_GSE * u.kpc,                        a=1, b=0.81, c=0.73, R=gse_rot, units=galactic)        # gse_rs = 12        # gse_spherical = gp.NFWPotential(m=halo_masses[t] * u.Msun * gse_fracs[t]/(1-gse_fracs[t]), r_s= gse_rs * u.kpc,        #                 a=1, b=1, c=1, units=galactic)        # gse_vc = gse_spherical.circular_velocity(np.array([gse_rs,0,0]))        pot = gp.MiyamotoNagaiPotential(**thick) + gp.MiyamotoNagaiPotential(**thin) +\            gp.HernquistPotential(**bulge) + gp.NFWPotential(**mw_halo) + gp.NFWPotential(**gse_halo)                # test_pot = gp.NFWPotential(**gse_halo)        # fig, ax = plt.subplots(dpi=300)         # test_pot.plot_contours(grid=(np.linspace(-15,15,100), np.linspace(-15,15,100),0), marker='', ax=ax)        # ax.set_aspect('equal')        # plt.show()        # fig, ax = plt.subplots(dpi=300)         # test_pot.plot_contours(grid=(np.linspace(-15,15,100), 0, np.linspace(-15,15,100)), marker='', ax=ax)        # ax.set_aspect('equal')        # plt.show()        # fig, ax = plt.subplots(dpi=300)         # test_pot.plot_contours(grid=(0, np.linspace(-15,15,100), np.linspace(-15,15,100)), marker='', ax=ax)        # ax.set_aspect('equal')        # plt.show()        pot_list.append(pot)        return pot_listdef initialize_realism(nsample, pot, scale_R):    # For now, assume we only sample from thin disk morphology.    scale_z = 0.03 #kpc    # zs = np.random.exponential(scale=scale_z, size=nsample)*np.random.choice([-1,1],size=nsample)    zs = np.zeros(nsample)        # Rs = 1 + np.random.exponential(scale=np.max([scale_R-1,1]), size=nsample)    Rs = truncexpon.rvs(b=8*scale_R, loc=1, scale=np.max([scale_R-1,1]),size=nsample)        phis = np.random.uniform(low=0.0, high=2*np.pi, size=nsample)    pos = np.vstack([Rs*np.cos(phis), Rs*np.sin(phis), zs])        vels = pot.circular_velocity(pos)    vxs, vys, vzs = -vels*np.sin(phis), vels*np.cos(phis), np.zeros(len(phis))    vxs, vys = -vxs, -vys # Make it rotate prograde    w0 = gd.PhaseSpacePosition(pos*u.kpc, np.vstack([vxs, vys, vzs]))    return w0def initialize_Ring(nsample, pot, Ring):    # For now, assume we only sample from thin disk morphology.    # zs = np.random.exponential(scale=scale_z, size=nsample)*np.random.choice([-1,1],size=nsample)    zs = np.zeros(nsample)        # Rs = 1 + np.random.exponential(scale=np.max([scale_R-1,1]), size=nsample)    Rs = Ring*np.ones(nsample)        phis = np.random.uniform(low=0.0, high=2*np.pi, size=nsample)    pos = np.vstack([Rs*np.cos(phis), Rs*np.sin(phis), zs])        vels = pot.circular_velocity(pos)    vxs, vys, vzs = -vels*np.sin(phis), vels*np.cos(phis), np.zeros(len(phis))    vxs, vys = -vxs, -vys # Make it rotate prograde    w0 = gd.PhaseSpacePosition(pos*u.kpc, np.vstack([vxs, vys, vzs]))    return w0def churn_pdf(dt, Nsize,sigma):    log_DRgrid = np.logspace(-5,np.log10(20),1000)    pdfs = np.exp(-log_DRgrid**2/(2*sigma**2*dt/8000))    cdfs = np.cumsum(pdfs*np.gradient(log_DRgrid))    cdfs /= cdfs[-1] # Make last element 1    invcdf_fn = interp1d(cdfs, log_DRgrid,bounds_error=False,fill_value=0)    return invcdf_fn(np.random.random(size=Nsize))def churn_step(warr, dt, sigma): # Radial migration    xs,ys,zs = warr.x.value, warr.y.value, warr.z.value    Nsize = len(xs)    if sigma==0:        DRs = np.zeros(Nsize)    else:        DRs = churn_pdf(dt, Nsize=Nsize, sigma=sigma)        DRs[ (np.abs(zs)>1) | (np.sqrt(xs**2+ys**2) > 20) ] = 0 # If |Z|>0.5, no churning    init_phi, init_R = np.arctan2(ys,xs), np.sqrt(xs**2+ys**2)    signs = np.random.choice([-1,1],p=[0.5,0.5],size=Nsize)        final_R = np.where(init_R + signs*DRs >= 1,  init_R + signs*DRs, init_R - signs*DRs)    new_x, new_y = final_R*np.cos(init_phi), final_R*np.sin(init_phi)        wnew = gd.PhaseSpacePosition(pos=np.vstack([new_x, new_y, zs])*u.kpc,                                   vel=warr.vel)        # plt.figure(dpi=400,figsize=(5,5))    # plt.title(r'$\Delta T$ = %d Myr' %dt)    # plt.scatter(xs,ys,s=.1,c='k', label='pre-migrate')    # plt.scatter(new_x, new_y ,s=.1,c='r', label='post-migrate')    # for i in range(Nsize):    #     plt.plot([new_x[i],xs[i]], [new_y[i],ys[i]],c='grey',lw=0.1)    # plt.xlim([-5,5])    # plt.ylim([-5,5])    # plt.legend()    # plt.show()        return wnewdef sticky_collision(warr, sticky_param):    # vel_new = np.zeros((3,len(warr.x)))        donelist = []    # for idx in tqdm.tqdm(range(len(warr.x))):    vel_new = warr.vel.get_d_xyz()        # for idx in range(len(warr.x)):    for idx in np.random.choice(len(warr.x),size=int(len(warr.x)/10)):        if idx in donelist:            # print("done")            continue        pos_1, vel_1 = warr[idx].pos, warr[idx].vel        distances = ((pos_1 - warr.pos).norm()).to(u.kpc).value        distances[distances==0] = 1000 # Exclude oneself        closest_neighbor = np.argmin(distances)        if np.min(distances) < 0.1:            # print("collide!")            pos_2, vel_2 = warr[closest_neighbor].pos, warr[closest_neighbor].vel            if np.abs(np.arccos(vel_1.to_cartesian().dot(vel_2.to_cartesian())/(vel_1.norm()*vel_2.norm()) ))< 90*u.deg:                new_vel_1 = ((-sticky_param+1)/2) * (vel_1-vel_2) + vel_2                new_vel_2 = ((-sticky_param+1)/2) * (vel_2-vel_1) + vel_1                vel_new[:,idx] = new_vel_1.get_d_xyz()                vel_new[:,closest_neighbor] = new_vel_2.get_d_xyz()            else:                vel_new[:,idx] = vel_1.get_d_xyz()                vel_new[:,closest_neighbor] = vel_2.get_d_xyz()            donelist.append(closest_neighbor)        else:            vel_new[:,idx] = warr[idx].vel.get_d_xyz()                return gd.PhaseSpacePosition(warr.pos, vel=vel_new)def wrapper(idx, warr, sticky_param):    # if idx in donelist:    #     return 0    pos_1, vel_1 = warr[idx].pos, warr[idx].vel    distances = (pos_1 - warr.pos).norm().value    distances[distances==0] = 1000 # Exclude oneself    closest_neighbor = np.argmin(distances)    if (pos_1-warr[closest_neighbor].pos).norm() < 0.1*u.kpc:        pos_2, vel_2 = warr[closest_neighbor].pos, warr[closest_neighbor].vel        if np.abs(np.arccos(vel_1.to_cartesian().dot(vel_2.to_cartesian())/(vel_1.norm()*vel_2.norm()) ))< 90*u.deg:            new_vel_1 = ((-sticky_param+1)/2) * (vel_1-vel_2) + vel_2            new_vel_2 = ((-sticky_param+1)/2) * (vel_2-vel_1) + vel_1            return new_vel_1.get_d_xyz()            # vel_new[:,closest_neighbor] = new_vel_2.get_d_xyz()        else:            return vel_1.get_d_xyz()            # vel_new[:,closest_neighbor] = vel_2.get_d_xyz()        # donelist.append(closest_neighbor)    else:        return  warr[idx].vel.get_d_xyz()def mpi_sticky_collision(warr, sticky_param):    npart = len(warr.x)    with Pool(NCPU) as p:        # r = list(tqdm.tqdm(p.starmap(wrapper, [(idx,warr,sticky_param) for idx in np.arange(npart)])))        r = list(p.starmap(wrapper, [(idx,warr,sticky_param) for idx in np.arange(npart)]))    return gd.PhaseSpacePosition(warr.pos, vel=np.vstack(r).T)def compute_R(w):    R = np.sqrt(w.x**2+w.y**2).value    return Rdef compute_signed_R(w):    R = np.sqrt(w.x**2+w.y**2).value    R = np.where(w.y.value<0, -R, R)    return Rdef compute_Lvec(w):    Lvec = w.pos.cross(w.vel)    return Lvecdef powerlaw_warp(x, y, a,b,rw,phi_w):    r = np.sqrt(x**2+y**2)    phi = np.arctan2(y,x)    return np.where(r>rw ,a* ((r-rw)**b) *np.sin(phi-np.radians(phi_w)), 0)def warp_prominence(w):    in_plane = np.sum(np.abs(w.z.value)<0.25)    out_plane = np.sum(np.abs(w.z.value)>=0.25)    return out_plane/in_planedef animate_growing_warp( R_GSE, R_SFR, tilt_angle=None, mass_frac=None): # ADD particles as we go!        nstep = 5000    tind = np.arange(nstep)    dt = 1.    pot_list = evolving_potential(dt,nstep,R_GSE, tilt_angle, mass_frac)    Rscale_list = R_SFR*(1- ( nstep - tind*dt) /8000 )    # Rscale_list = 6*np.ones(nstep)    # First, initialize conditions    Rmax = 25        nsample_final = 80000    # nsample_final = 20000    nsample_init = int(nsample_final * (3/8))        nsample_add = int((nsample_final-nsample_init)/nstep)    print("Adding %d particles per timestep\n" %nsample_add)        agelist=[]    birthRlist=[]    w0 = initialize_realism(nsample_init, pot_list[0],Rscale_list[0])    for i in range(nsample_init):        agelist.append(dt*nstep)    birthRlist.extend(compute_R(w0))    wlist = [w0]    print("Beginning orbit int...\n")    for i in tqdm.tqdm((range(nstep))):        pot = pot_list[i]        w0 = pot.integrate_orbit(w0, dt=dt*u.Myr, n_steps=1)[-1] # Integrate one step        w1 = initialize_realism(nsample_add, pot, Rscale_list[i])        # Now update w0 include newly spawned stars        w0 = gd.PhaseSpacePosition(pos=np.hstack([w0.pos.get_xyz(),w1.pos.get_xyz()]),                                   vel=np.hstack([w0.vel.get_d_xyz(),w1.vel.get_d_xyz()]))        birthRlist.extend(compute_R(w1))        for j in range(nsample_add):            agelist.append(dt*(nstep-i+1))        w0 = churn_step(w0, dt, sigma=3.6) # Radial migration        # w0 = mpi_sticky_collision(w0, 0.9)        w0 = sticky_collision(w0,0.9)        wlist.append(w0)        return wlist,agelist, birthRlist# wlist_nostick,agelist_nostick,birthRlist_nostick = animate_growing_warp(R_GSE=30, R_SFR=8*(8/8.5),tilt_angle=25)wlist,agelist,birthRlist = animate_growing_warp(R_GSE=30, R_SFR=8*(8/8.5),tilt_angle=25)# wlist_nostick,agelist_nostick,birthRlist_nostick = wlist,agelist,birthRlist # track_fig.show()#%%def plot_warp_growth(wlist):    R_SFR=8*(8/8.5)    nstep = 5000    tind = np.arange(nstep+1)    dt = 1.    Rscale_list = R_SFR*(1- ( nstep - tind*dt) /8000 )        amps = []    amp_unc = []    times = []    for step in tqdm.tqdm(range(len(wlist))):        if step%10==0:            w0 = wlist[step]            phis = np.arctan2(w0.y.value, w0.x.value)             Rs = np.sqrt(w0.y.value**2+w0.x.value**2)            loc, scale = expon.fit(Rs)            plot_radius = 16*(8.5/8.) # kpc            mask = (Rs >plot_radius-1) & (Rs < plot_radius+1)                        sinwarp = lambda x, aa, pp: aa*np.sin(np.radians(x-pp))            popt, pcov = curve_fit(sinwarp, xdata=phis[mask], ydata=w0.z.value[mask],                                    bounds = np.array([(0,10),(0,360)]).T)                        TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)            popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x.value,w0.y.value]).T,ydata=w0.z.value,                                    bounds=np.array([(0,10),(1,5),(0,1),(-180,180)]).T)            # popt[-1] = 0                        plot_phis = np.linspace(-np.pi, np.pi-0.001,100)            Xs, Ys = plot_radius*np.cos(plot_phis), plot_radius*np.sin(plot_phis)            psamples = np.random.multivariate_normal(mean=popt, cov=pcov, size=100)            Zs = [ np.max(powerlaw_warp(Xs,Ys,*ps)) for ps in psamples]            amps.append( np.median(Zs))            amp_unc.append(np.std(Zs))            times.append(step)    return times, amps, amp_unctimes, amps,amp_unc = plot_warp_growth(wlist_nostick)#%%folder = '/Users/jhan/Science/Theory/Disk Tilting/Paper/Nastro_fig/'plt.figure(dpi=300,figsize=(8,4))plt.scatter(times, amps, s=0.1, c='k')plt.errorbar(times, amps, yerr= amp_unc, ecolor='k', ls='none', elinewidth=0.1)plt.xlabel('Time [Myr]')plt.ylabel('Warp Amplitude [kpc] @ 16kpc')plt.savefig(folder+'warp_growth.pdf')plt.show()#%%def plot_longwarp(wlist, step):    w0 = wlist[step]        TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)    popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x.value,w0.y.value]).T,ydata=w0.z.value,                           bounds=np.array([(0,10),(1,5),(0,1),(-180,180)]).T)    popt[-1] = 0    # phis = np.arctan2(w0.y.value, w0.x.value)     plot_radius = 16*(8.5/8.) # kpc    plot_phis = np.linspace(-np.pi, np.pi-0.001,100)    Xs, Ys = plot_radius*np.cos(plot_phis), plot_radius*np.sin(plot_phis)    Zs = powerlaw_warp(Xs,Ys,*popt)    # Zs = powerlaw_warp(Xs,Ys,popt[0],popt[1],popt[2],0)    gc = coord.SkyCoord(Xs*u.kpc,Ys*u.kpc,Zs*u.kpc,                       frame=coord.Galactocentric,                       galcen_distance = 8. * u.kpc)    gc = gc.transform_to(coord.Galactic)        hi_orientation = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/orientation.dat', sep='\s+',names=['l','z'])    lmc_high = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/lmc_highmass.dat', sep='\s+',names=['l','z'])    lmc_low = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/lmc_lowmass.dat', sep='\s+',names=['l','z'])    hi_raw = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/HI_longitude.csv', sep=',',names=['l','z'])    hi_raw['l'] = -hi_raw['l']    hi_poly = np.poly1d(np.polyfit(hi_raw['l'], hi_raw['z'],5))    hi_unc = np.std(hi_raw['z'] - hi_poly(hi_raw['l'])) # Average deviation from curve        fig = plt.figure(dpi=400,figsize=(10,4))    # fig.suptitle('Disk Warp at R=16 kpc', y=0.95)    gs = GridSpec(1,2,fig, wspace=0.02)    ax0, ax2 = fig.add_subplot(gs[0]),fig.add_subplot(gs[1])    ax0.set_ylabel('Height [kpc]', fontsize=12)    ax0.plot(Angle(gc.l).wrap_at(180*u.deg), Zs, c='b', label='Tilted Dark Halo Model', lw=0.7,zorder=5000)        # ax0.plot(np.degrees(plot_phis), hi_poly(np.degrees(plot_phis)), c='k')        ax0.scatter(np.degrees(lmc_high['l']), lmc_high['z'],s=0.5,c='r',marker='X',alpha=0.1)    lmc_high_poly = np.poly1d( np.polyfit(lmc_high['l'],lmc_high['z'], 6))    ax0.plot(np.degrees(plot_phis), lmc_high_poly(plot_phis), lw=0.7,c='r',label=r'LMC$_1$ Model: 2.5$\times$10$^{11}$ $M_{\odot}$')        ax0.scatter(np.degrees(lmc_low['l']), lmc_low['z'],s=0.5,c='r',marker='X',alpha=0.1)    lmc_low_poly = np.poly1d( np.polyfit(lmc_low['l'],lmc_low['z'], 6))    ax0.plot(np.degrees(plot_phis), lmc_low_poly(plot_phis), lw=0.7,c='xkcd:pink',label=r'LMC$_2$ Model: 1$\times$10$^{11}$ $M_{\odot}$')    # ax2.plot(np.degrees(plot_phis), lmc_high_poly(plot_phis) + Zs,lw=0.7, c='xkcd:purple', label='Tilted Halo + LMC$_1$',zorder=5000)    ax2.plot(np.degrees(plot_phis), lmc_low_poly(plot_phis) + Zs,lw=0.7, c='xkcd:purple', label='Tilted Dark Halo + LMC$_2$',zorder=5010)    mc_Zs = []    for i in range(1000):        psample = np.zeros(4)        for j in range(4):            psample[j] = np.random.normal(loc=popt[j],scale=1.*np.sqrt(pcov[j,j]))        # ax0.plot(Angle(gc.l).wrap_at(180*u.deg), Zs, lw=0.1,alpha=0.1,c='xkcd:cornflower blue')        # ax2.plot(np.degrees(plot_phis), lmc_high_poly(plot_phis) + Zs,lw=0.1,alpha=0.1,c='xkcd:violet',zorder=0)        # ax2.plot(np.degrees(plot_phis), lmc_low_poly(plot_phis) + Zs,lw=0.1,alpha=0.1,c='xkcd:bluish green')        mc_Zs.append(powerlaw_warp(Xs,Ys,*psample))    mc_low = np.percentile(np.array(mc_Zs),50-34.1,axis=0)    mc_high = np.percentile(np.array(mc_Zs),50+34.1,axis=0)        ax0.fill_between(Angle(gc.l).wrap_at(180*u.deg).value, mc_low, mc_high,                     alpha=0.5,fc='xkcd:cornflower blue')    # ax2.fill_between(np.degrees(plot_phis), lmc_high_poly(plot_phis) + mc_low,lmc_high_poly(plot_phis) + mc_high,                      # alpha=0.4,fc='xkcd:violet')    ax2.fill_between(np.degrees(plot_phis), lmc_low_poly(plot_phis) + mc_low,lmc_low_poly(plot_phis) + mc_high,                      alpha=0.5,fc='xkcd:violet',zorder=1000)            for ax in [ax0,ax2]:        # ax.plot(-hi_orientation['l'], hi_orientation['z'],lw=0.7,c='k',ls='dashed', zorder=5003)        # ax.scatter(hi_raw['l'], hi_raw['z'], s=0.1, c='k', alpha=0.5)        l1 = ax.errorbar(hi_raw['l'], hi_raw['z'],yerr=hi_unc, c='k', alpha=0.5,                      linestyle='None', linewidth=0.3, marker='o',ms=2,zorder=0,                      markerfacecolor='none', markeredgewidth=0.5,ecolor='grey')                ax.text(s=r'$\circ$ HI Height at R=16 kpc $\pm$ 1$\sigma$', x=15, y=1.6)        ax.set_ylim([-2,2])        ax.set_xlim([175,-175])        # ax.set_ylabel('Height [kpc]')        ax.set_xlabel('Galactic Longitude (deg)', fontsize=12)        ax.legend(frameon=False, loc='lower left',alignment='right')            # ax1.set_yticks([])    ax2.set_yticks([])    plt.tight_layout()    plt.savefig(folder+'LMC_compare.pdf')    plt.show()    pass# plot_longwarp(wlist, -1)plot_longwarp(wlist_nostick, -1)#%%def plot_LON_R():    w0 = wlist_nostick[-1]    rbins = np.arange(8,18.1,1)    philist=[]    for rmin, rmax in zip(rbins[:-1],rbins[1:]):        mask = (compute_R(w0)>rmin) & (compute_R(w0)<rmax) & (np.array(agelist_nostick)<200)        TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)        popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x.value[mask],w0.y.value[mask]]).T,ydata=w0.z.value[mask],                               bounds=np.array([(0,10),(1,5),(0,1),(-180,180)]).T)        philist.append((-(popt[-1]-90), np.sqrt(pcov[-1,-1])))    philist = np.array(philist)        fn_fit = np.poly1d( np.polyfit(x=(rbins[:-1]+rbins[1:])/2 ,y=philist[:,0], deg=4))    error_fit = np.poly1d( np.polyfit(x=(rbins[:-1]+rbins[1:])/2 , y=philist[:,1],deg=4))        lon_mean = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/LON_mean.csv', sep=',', names=['R','ang'],dtype=float)    lon_high = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/LON_high.csv', sep=',', names=['R','ang'],dtype=float)        plt.figure(dpi=300,figsize=(10,3))    rgrid = np.linspace(lon_mean['R'].min(), lon_mean['R'].max(), 100)    # plt.errorbar( (rbins[:-1]+rbins[1:])/2 , philist[:,0], yerr=philist[:,1], label='Han 23',    #               fmt='b-', linewidth=1)    l1, = plt.plot( rgrid, fn_fit(rgrid), c='b', label='Disk Stars in Tilted Dark Halo (age < 200 Myr)', lw=1.0)    plt.fill_between(rgrid, fn_fit(rgrid)+error_fit(rgrid), fn_fit(rgrid)-error_fit(rgrid),                     alpha=0.2, fc='xkcd:cornflower blue')        l2,_,_ = plt.errorbar(lon_mean['R'],lon_mean['ang'], yerr=np.abs(lon_high['ang']-lon_mean['ang']),label='Disk Cepheids (Chen 19)',                 linewidth=0.5, c='b', linestyle='None', marker='o',capsize=1, ms=3)        philist=[]    for rmin, rmax in zip(rbins[:-1],rbins[1:]):        mask = (compute_R(w0)>rmin) & (compute_R(w0)<rmax) & (np.array(agelist_nostick)>200)        TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)        popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x.value[mask],w0.y.value[mask]]).T,ydata=w0.z.value[mask],                               bounds=np.array([(0,10),(1,5),(0,1),(-180,180)]).T)        philist.append((-(popt[-1]-90), np.sqrt(pcov[-1,-1])))    philist = np.array(philist)        fn_fit = np.poly1d( np.polyfit(x=(rbins[:-1]+rbins[1:])/2 ,y=philist[:,0], deg=4))    error_fit = np.poly1d( np.polyfit(x=(rbins[:-1]+rbins[1:])/2 , y=philist[:,1],deg=4))    l3, = plt.plot( rgrid, fn_fit(rgrid), c='r', label='Disk Stars in Tilted Dark Halo (age > 200 Myr)', lw=1.0)    plt.fill_between(rgrid, fn_fit(rgrid)+error_fit(rgrid), fn_fit(rgrid)-error_fit(rgrid),                     alpha=0.2, fc='xkcd:rose')        l4 = plt.axhline(y=0, xmin=0, xmax=20, ls='solid', lw=0.5, c='k', label='$\phi$ of Dark Halo')    l5 = plt.axhline(y=24.33, xmin=0, xmax=20, ls='dashed', lw=0.5, c='k', label='$\phi$ of Stellar Halo')    # plt.text(s=r'--- $\phi$ of Dark Halo', x=15.5,y=-10)    # plt.text(s=r'--- $\phi$ of Stellar Halo', x=15.5,y=-10)    plt.ylim([-50,90])    plt.xlim([8.,18])    # plt.legend(frameon=False, loc='upper left')    plt.xlabel('R [kpc]')    plt.ylabel(r'$\phi$ [degrees]')        legend1 = plt.legend([l2,l1,l3],["Disk Cepheids", "Disk Stars in Tilted Dark Halo (age < 500 Myr)", "Disk Stars in Tilted Dark Halo (age > 500 Myr)"], loc='upper left', frameon=False)    plt.gca().add_artist(legend1)    legend2 = plt.legend([l5], ['$\phi$ of Stellar & Dark Halo'], loc='upper right', frameon=False)    plt.gca().add_artist(legend2)                plt.show()    passplot_LON_R()#%% Volume renderingfrom scipy import statsfrom mpl_toolkits.mplot3d import Axes3Dimport plotly.graph_objects as goX, Y, Z = np.mgrid[-20:20:50j, -20:20:50j, -2:2:50j]kde = stats.gaussian_kde( wlist_nostick[-1].pos.xyz.value,)density = kde(np.vstack([X.ravel(), Y.ravel(), Z.ravel()]))density_3d = density.reshape(X.shape)# fig = go.Figure(data=go.Volume(#     x=X.flatten(),#     y=Y.flatten(),#     z=Z.flatten(),#     value=np.log10(density.flatten()),#     isomin=-4.5,#     isomax=-1,#     opacity=0.3, # needs to be small to see through all surfaces#     surface_count=70, # needs to be a large number for good volume rendering#     colorscale='magma',#     ))# fig.write_html("rendering_ld.html")np.save('volume.npy', density_3d, allow_pickle=False)#%%from scipy.interpolate import interpn# density = np.load('volume.npy')"""Create Your Own Volume Rendering (With Python)Philip Mocz (2020) Princeton Univeristy, @PMoczSimulate the Schrodinger-Poisson system with the Spectral method"""def transferFunction(x, dens):	    r = 1.0*np.exp( -(x - np.median(dens))**2/1.0 ) #+  0.1*np.exp( -(x - np.median(dens)*0.1)**2/0.1 )    g = 1.0*np.exp( -(x - np.median(dens))**2/1.0 ) #+  1.0*np.exp( -(x - np.median(dens)*0.1)**2/0.1 )    b = 0.1*np.exp( -(x - np.median(dens))**2/1.0 ) #+  0.1*np.exp( -(x - np.median(dens)*0.1)**2/0.1 )    a = 0.6*np.exp( -(x - np.median(dens))**2/1.0 ) #+  0.1*np.exp( -(x - np.median(dens)*0.1)**2/0.1 )        return r,g,b,adef render():	""" Volume Rendering """		datacube = (density*1e8).reshape(X.shape)	# Datacube Grid	Nx, Ny, Nz = datacube.shape	x = np.linspace(-20, 20, Nx)	y = np.linspace(-20, 20, Ny)	z = np.linspace(-2,2, Nz)	points = (x, y, z)		# Do Volume Rendering at Different Veiwing Angles	Nangles = 1	for i in range(Nangles):				print('Rendering Scene ' + str(i+1) + ' of ' + str(Nangles) + '.\n')        # Camera Grid / Query Points -- rotate camera view		angle = np.pi/2 * i / Nangles		N = 100		c = np.linspace(-N/2, N/2, N)		qx, qy, qz = np.meshgrid(c,c,c)		qxR = qx		qyR = qy * np.cos(angle) - qz * np.sin(angle) 		qzR = qy * np.sin(angle) + qz * np.cos(angle)		qi = np.array([qxR.ravel(), qyR.ravel(), qzR.ravel()]).T		# Interpolate onto Camera Grid		camera_grid = interpn(points, values=datacube, xi=qi, method='linear',bounds_error=False).reshape((N,N,N))		# Do Volume Rendering		image = np.zeros((camera_grid.shape[1],camera_grid.shape[2],3))			for dataslice in camera_grid:			r,g,b,a = transferFunction(np.log(dataslice), density)			image[:,:,0] = a*r + (1-a)*image[:,:,0]			image[:,:,1] = a*g + (1-a)*image[:,:,1]			image[:,:,2] = a*b + (1-a)*image[:,:,2]            		print(r,g,b,a)# 		image = np.clip(image,0.0,1.0)				# Plot Volume Rendering		plt.figure(figsize=(4,4), dpi=400)				plt.imshow(image)		plt.axis('off')		plt.show()		# Save figure# 		plt.savefig('volumerender' + str(i) + '.png',dpi=240,  bbox_inches='tight', pad_inches = 0)	return 0	render()#%%def gridded_growing_warp(R_GSE, R_SFR): # ADD particles as we go!        nstep = 5000    tind = np.arange(nstep)    dt = 1.    pot_list = evolving_potential(dt,nstep,R_GSE)    Rscale_list = R_SFR*(1- ( 5000 - tind*dt) /8000 )        nsample_final = 50000    nsample_init = int(nsample_final * (3/8))        nsample_add = int((nsample_final-nsample_init)/nstep)    print("Adding %d particles per timestep\n" %nsample_add)        agelist=[]    birthRlist=[]    w0 = initialize_realism(nsample_init, pot_list[0],Rscale_list[0])    for i in range(nsample_init):        agelist.append(dt*nstep)    birthRlist.extend(compute_R(w0))    # wlist = [w0]    print("Beginning orbit int...\n")    for i, step in enumerate(range(nstep)):        # if i%100==0:        #     print(i)        pot = pot_list[i]        w0 = pot.integrate_orbit(w0, dt=dt*u.Myr, n_steps=1)[-1] # Integrate one step        w1 = initialize_realism(nsample_add, pot, Rscale_list[i])        # Now update w0 include newly spawned stars        w0 = gd.PhaseSpacePosition(pos=np.hstack([w0.pos.get_xyz(),w1.pos.get_xyz()]),                                   vel=np.hstack([w0.vel.get_d_xyz(),w1.vel.get_d_xyz()]))        birthRlist.extend(compute_R(w1))        for j in range(nsample_add):            agelist.append(dt*(nstep-step+1))        w0 = churn_step(w0, dt, sigma=3.6) # Radial migration        # wlist.append(w0)        return w0, agelist, birthRlistR_GSE_min,R_GSE_max, dR_GSE = 20, 40, 10R_GSE_grid = np.arange(R_GSE_min,R_GSE_max+0.1,dR_GSE)R_SFR_min,R_SFR_max,dR_SFR = 3, 9, 3R_SFR_grid = np.arange(R_SFR_min,R_SFR_max+0.1,dR_SFR)rgrg, rsrs = np.meshgrid(R_GSE_grid,R_SFR_grid, indexing='ij')coordinate_keys = list(zip(rgrg.flatten(),rsrs.flatten()))result_dict={}for i,key in enumerate(coordinate_keys):    result_dict[key] = gridded_growing_warp(*key)    print(i)    # Grid in mass fraction and tilt angledef mass_gridded_growing_warp(tilt_angle, mass_frac): # ADD particles as we go!        nstep = 5000    tind = np.arange(nstep)    dt = 1.    pot_list = evolving_potential(dt,nstep,30,tilt_angle, mass_frac)    Rscale_list = 8*(1- ( 5000 - tind*dt) /8000 )        nsample_final = 50000    nsample_init = int(nsample_final * (3/8))    nsample_add = int((nsample_final-nsample_init)/nstep)        agelist=[]    birthRlist=[]    w0 = initialize_realism(nsample_init, pot_list[0],Rscale_list[0])    for i in range(nsample_init):        agelist.append(dt*nstep)    birthRlist.extend(compute_R(w0))    # wlist = [w0]    print("Beginning orbit int...\n")    for i, step in enumerate(range(nstep)):        # if i%100==0:        #     print(i)        pot = pot_list[i]        w0 = pot.integrate_orbit(w0, dt=dt*u.Myr, n_steps=1)[-1] # Integrate one step        w1 = initialize_realism(nsample_add, pot, Rscale_list[i])        # Now update w0 include newly spawned stars        w0 = gd.PhaseSpacePosition(pos=np.hstack([w0.pos.get_xyz(),w1.pos.get_xyz()]),                                   vel=np.hstack([w0.vel.get_d_xyz(),w1.vel.get_d_xyz()]))        birthRlist.extend(compute_R(w1))        for j in range(nsample_add):            agelist.append(dt*(nstep-step+1))        w0 = churn_step(w0, dt, sigma=3.6) # Radial migration        # wlist.append(w0)        return w0, agelist, birthRlisttilt_min, tilt_max = 0, 50tilt_grid = np.linspace(tilt_min,tilt_max,3)mass_min,mass_max = 0.1, 0.31mass_grid = np.linspace(mass_min,mass_max, 3)rgrg, rsrs = np.meshgrid(tilt_grid,mass_grid, indexing='ij')coordinate_keys = list(zip(rgrg.flatten(),rsrs.flatten()))mass_result_dict={}for i,key in enumerate(coordinate_keys):    mass_result_dict[key] = mass_gridded_growing_warp(*key)    print(i)#%%fig=plt.figure(dpi=400,figsize=(12,12))superax= fig.add_axes([0.04,0.04, 0.9,0.9])superax.set_title('Variation of Model Parameters', fontsize=20)# Hide the right and top spinessuperax.spines.right.set_visible(False)superax.spines.top.set_visible(False)# Only show ticks on the left and bottom spinessuperax.yaxis.set_ticks_position('left')superax.xaxis.set_ticks_position('bottom')superax.set_yticks(R_GSE_grid)superax.set_xticks(R_SFR_grid)superax.set_ylim([R_GSE_min-5,R_GSE_max+5])superax.set_xlim([R_SFR_min-1.5,R_SFR_max+1])superax.tick_params(axis='both', labelsize=16)superax.set_ylabel('TILTED DARK HALO SCALE LENGTH [kpc]',labelpad=15,fontsize=18)superax.set_xlabel('TRACER PARTICLE SCALE LENGTH [kpc]',labelpad=15,fontsize=18)gs = GridSpec(len(R_GSE_grid), len(R_SFR_grid), fig,left=0.12,right=0.9,bottom=0.1,top=0.9,              wspace=0.3,hspace=0.3)for i,r_gse in enumerate(R_GSE_grid):    for j,r_sfr in enumerate(R_SFR_grid):        ax = fig.add_subplot(gs[-i-1,j])        w0,agelist,birthRlist = result_dict[(r_gse,r_sfr)]        ind = (np.array(agelist)>=0) & (np.array(agelist)<=1000) & (compute_R(w0)<20)        # ax.scatter(w0.x, w0.z, s=0.1, c=agelist,norm=clr.Normalize(0,5000),cmap='bwr')        # ax.scatter(w0.x, w0.z, s=0.1, c=birthRlist,norm=clr.Normalize(0,15),cmap='bwr')        # ax.scatter(w0.x[ind], w0.z[ind], s=0.1, c=np.array(birthRlist)[ind],norm=clr.Normalize(0,15),cmap='RdBu')        OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)        TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)                # popt, pcov = curve_fit(OneDwarp, xdata=w0.x[ind].value,ydata=w0.z[ind].value,                                # bounds=np.array([(0,10),(0,10),(1,20),(0,360)]).T)        prom = warp_prominence(w0) # Prominence of wrap        if prom > 0.005:            popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x[ind].value,w0.y[ind].value]).T,ydata=w0.z[ind].value,                                    bounds=np.array([(0,10),(1,5),(7,10),(0,360)]).T)                        phis = np.arctan2(w0.y[ind].value, w0.x[ind].value)            signs = np.where( np.sin(phis- np.radians(popt[-1]))<0 ,1,-1)            ax.scatter(signs*compute_R(w0[ind]),w0.z[ind],  c=np.array(agelist)[ind],                        cmap='RdBu_r', s=0.1)                        ax.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),*popt),                    lw=1, ls='dashed', c='k', label=r'$Z_{20}$'+' = %.1f kpc '%(popt[0]*(20-popt[2])**popt[1]),                    alpha=0.8)            lgnd=ax.legend(loc='lower left',frameon=True,edgecolor='w',markerscale=0.1,fontsize=11)            lgnd.legendHandles[0]._sizes = [1]        else:            phis = np.arctan2(w0.y[ind].value, w0.x[ind].value)            signs = np.where(np.abs(phis)<np.pi/2, 1, -1)            ax.scatter(signs*compute_R(w0[ind]),w0.z[ind],  c=np.array(agelist)[ind],                        cmap='RdBu_r', s=0.1)        ax.text(x=-10,y=1.5,s=r'$N_{warp}/N_{plane}=$'+"%.1f%%"%(prom*100),fontsize=11)        ax.set_xlim([-25,25])        ax.set_ylim([-2,2])        ax.tick_params(axis='both', which='major', labelsize=10)        ax.set_ylabel(r'$Z$ [kpc]')        ax.set_xlabel(r'$R$ [kpc]')        cax = fig.add_axes([0.95, 0.1, 0.015, 0.8])cbar=plt.colorbar(cm.ScalarMappable(norm=clr.Normalize(0,5), cmap='RdBu_r'), cax=cax, orientation='vertical')cbar.ax.set_ylabel('Age [Gyr]', rotation=270,labelpad=18,fontsize=16)ax.tick_params(axis='both', which='major', labelsize=15)# cbar.ax.set_ylabel('Birth Radius [kpc]', rotation=270,labelpad=15,fontsize=12)plt.savefig(folder+'scale_lengths.pdf',bbox_inches='tight')plt.show()#%%fig=plt.figure(dpi=400,figsize=(12,12))superax= fig.add_axes([0.04,0.04, 0.9,0.9])superax.set_title('Variation of Model Parameters', fontsize=20)# Hide the right and top spinessuperax.spines.right.set_visible(False)superax.spines.top.set_visible(False)# Only show ticks on the left and bottom spinessuperax.yaxis.set_ticks_position('left')superax.xaxis.set_ticks_position('bottom')superax.set_xticks([0.1,0.2,0.3])superax.set_yticks(tilt_grid)superax.set_xlim([0.04,0.35])superax.set_ylim([-15,60])superax.tick_params(axis='both', labelsize=16)superax.set_xlabel('TILTED MASS FRACTION',labelpad=15,fontsize=18)superax.set_ylabel('TILT ANGLE [deg]',labelpad=15,fontsize=18)gs = GridSpec(len(R_GSE_grid), len(R_SFR_grid), fig,left=0.12,right=0.9,bottom=0.1,top=0.9,              wspace=0.3,hspace=0.3)for i,tilt in enumerate(tilt_grid):    for j,mass in enumerate(mass_grid):        ax = fig.add_subplot(gs[-i-1,j])        w0,agelist,birthRlist = mass_result_dict[(tilt,mass)]        ind = (np.array(agelist)>=0) & (np.array(agelist)<=1000) & (compute_R(w0)<20)        # ax.scatter(w0.x, w0.z, s=0.1, c=agelist,norm=clr.Normalize(0,5000),cmap='bwr')        # ax.scatter(w0.x, w0.z, s=0.1, c=birthRlist,norm=clr.Normalize(0,15),cmap='bwr')                # ax.scatter(w0.x[ind], w0.z[ind], s=0.1, c=np.array(birthRlist)[ind],norm=clr.Normalize(0,15),cmap='RdBu')        OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)        TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)                # popt, pcov = curve_fit(OneDwarp, xdata=w0.x[ind].value,ydata=w0.z[ind].value,                                # bounds=np.array([(0,10),(0,10),(1,20),(0,360)]).T)        prom = warp_prominence(w0) # Prominence of wrap        if prom > 0.005:            popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x[ind].value,w0.y[ind].value]).T,ydata=w0.z[ind].value,                                    bounds=np.array([(0,10),(1,5),(7,10),(0,360)]).T)            phis = np.arctan2(w0.y[ind].value, w0.x[ind].value)            signs = np.where( np.sin(phis- np.radians(popt[-1]))<0 ,1,-1)            ax.scatter(signs*compute_R(w0[ind]),w0.z[ind],  c=np.array(agelist)[ind],                        cmap='RdBu_r', s=0.1)                        ax.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),*popt),                    lw=1, ls='dashed', c='k', label=r'$Z_{20}$'+' = %.1f kpc '%(popt[0]*(20-popt[2])**popt[1]),                    alpha=0.8)            lgnd=ax.legend(loc='lower left',frameon=True,edgecolor='w',markerscale=0.1,fontsize=11)            lgnd.legendHandles[0]._sizes = [1]                    else:            phis = np.arctan2(w0.y[ind].value, w0.x[ind].value)            signs = np.where(np.abs(phis)<np.pi/2, 1, -1)            ax.scatter(signs*compute_R(w0[ind]),w0.z[ind],  c=np.array(agelist)[ind],                        cmap='RdBu_r', s=0.1)        ax.text(x=-10,y=1.5,s=r'$N_{warp}/N_{plane}=$'+"%.1f%%"%(prom*100),fontsize=11)        ax.set_xlim([-25,25])        ax.set_ylim([-2,2])        ax.tick_params(axis='both', which='major', labelsize=10)        ax.set_ylabel(r'$Z$ [kpc]')        ax.set_xlabel(r'$R$ [kpc]')        cax = fig.add_axes([0.95, 0.1, 0.015, 0.8])cbar=plt.colorbar(cm.ScalarMappable(norm=clr.Normalize(0,5), cmap='RdBu_r'), cax=cax, orientation='vertical')cbar.ax.set_ylabel('Age [Gyr]', rotation=270,labelpad=18,fontsize=16)ax.tick_params(axis='both', which='major', labelsize=15)plt.savefig(folder+'massfrac.pdf',bbox_inches='tight')plt.show()#%%fig=plt.figure(dpi=400,figsize=(12,12))superax= fig.add_axes([0.04,0.04, 0.9,0.9])# Hide the right and top spinessuperax.spines.right.set_visible(False)superax.spines.top.set_visible(False)# Only show ticks on the left and bottom spinessuperax.yaxis.set_ticks_position('left')superax.xaxis.set_ticks_position('bottom')superax.set_yticks(np.arange(R_GSE_min,R_GSE_max+0.1+dR_GSE,dR_GSE))superax.set_xticks(np.arange(R_SFR_min,R_SFR_max+0.1+dR_SFR,dR_SFR))superax.set_ylim([R_GSE_min-dR_GSE,R_GSE_max+dR_GSE])superax.set_xlim([R_SFR_min-dR_SFR,R_SFR_max+dR_SFR])superax.tick_params(axis='both', labelsize=16)superax.set_ylabel('TILTED DARK HALO SCALE LENGTH [kpc]',labelpad=15,fontsize=18)superax.set_xlabel('z=0 SFR SCALE LENGTH [kpc]',labelpad=15,fontsize=18)gs = GridSpec(len(R_GSE_grid), len(R_SFR_grid), fig,left=0.12,right=0.9,bottom=0.1,top=0.9,              wspace=0.3,hspace=0.3)for i,r_gse in enumerate(R_GSE_grid):    for j,r_sfr in enumerate(R_SFR_grid):        ax = fig.add_subplot(gs[-i-1,j])        w0,agelist,birthRlist = result_dict[(r_gse,r_sfr)]        ind = (np.array(agelist)>=0) & (np.array(agelist)<=1000) & (compute_R(w0)<20)        OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)        TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)                        prom = warp_prominence(w0) # Prominence of wrap        popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x[ind].value,w0.y[ind].value]).T,ydata=w0.z[ind].value,                                bounds=np.array([(0,10),(1,5),(7,10),(0,360)]).T)                # deltaZ = np.abs(w0.z[ind].value - TwoDwarp(np.vstack([w0.x[ind].value,w0.y[ind].value]).T,*popt))        deltaZ = w0.z[ind].value - TwoDwarp(np.vstack([w0.x[ind].value,w0.y[ind].value]).T,*popt)        Lvec = compute_Lvec(w0)        # ax.scatter(compute_R(w0[ind]), deltaZ, s=0.1, c=np.array(birthRlist)[ind],norm=clr.Normalize(0,15),cmap='bwr')        # ax.scatter(compute_R(w0[ind]), deltaZ, s=0.1, c=np.array(agelist)[ind],norm=clr.Normalize(0,1000),cmap='bwr')        ax.scatter(compute_R(w0[ind]), deltaZ, s=0.1, c=np.abs(Lvec.z[ind]/Lvec.norm()[ind]),norm=clr.Normalize(0.9997,1),cmap='bwr')                # lgnd=ax.legend(loc='lower left',frameon=True,edgecolor='w',markerscale=0.1,fontsize=9)        # lgnd.legendHandles[0]._sizes = [1]        # ax.text(x=-5,y=1.5,s=r'$N_{warp}/N_{plane}=$'+"%.1f%%"%(prom*100),fontsize=11)        ax.tick_params(axis='both', which='major', labelsize=12)                ax.set_xlim([0,20])        ax.set_ylim([-1.5,1.5])        ax.set_ylabel(r'$\Delta Z$ [kpc]')        ax.set_xlabel(r'$R$ [kpc]')# cbar=plt.colorbar(cm.ScalarMappable(norm=clr.Normalize(0,15), cmap='bwr'), cax=cax, orientation='vertical')# cbar.ax.set_ylabel('Birth Radius [kpc]', rotation=270,labelpad=15,fontsize=12)# cbar=plt.colorbar(cm.ScalarMappable(norm=clr.Normalize(0,1000), cmap='bwr'), cax=cax, orientation='vertical')# cbar.ax.set_ylabel('Age [Myr]', rotation=270,labelpad=15)cax = fig.add_axes([0.95, 0.1, 0.015, 0.8])cbar=plt.colorbar(cm.ScalarMappable(norm=clr.Normalize(0.9997,1), cmap='bwr'), cax=cax, orientation='vertical')cbar.ax.set_ylabel('Lz / Ltot', rotation=270,labelpad=20, fontsize=16)cbar.ax.tick_params(axis='both', which='major', labelsize=15)plt.show()#%%def mono_age_warp(minage, maxage):        wstep = wlist[-1]    inds = (np.array(agelist)>=minage) & (np.array(agelist)<=maxage)    R = np.sqrt(wstep.x[inds]**2+ wstep.y[inds]**2).value    Lvec = compute_Lvec(wstep[inds])        fig=plt.figure(dpi=400,figsize=(12,5))    # plt.title('%.1f < Age [Gyr] < %.1f' %(minage/1e3, maxage/1e3))    gs = GridSpec(1,2,fig)    ax0,ax1 = fig.add_subplot(gs[0]),fig.add_subplot(gs[1])    Rmax=25        # a,b,rw,phi = 0.06, 1.7, 7, -17    # ZX_warp = powerlaw_warp(np.linspace(-Rmax,Rmax,100), np.zeros(100),a,b,rw,phi)    # ZY_warp = powerlaw_warp(0, np.linspace(-Rmax,Rmax,100),a,b,rw,phi)    # ax0.plot(np.linspace(-Rmax,Rmax,100),ZX_warp,lw=1,c='k',label='Cepheids')    # ax1.plot(np.linspace(-Rmax,Rmax,100),ZY_warp,lw=1,c='k',label='Cepheids')        ax0.scatter(wstep.x[inds], wstep.z[inds], s=.1, alpha=1,                c=np.abs(Lvec.z/Lvec.norm()), norm=clr.LogNorm(0.9995,1),cmap='bwr')    ax1.scatter(wstep.y[inds], wstep.z[inds], s=.1, alpha=1,                c=np.abs(Lvec.z/Lvec.norm()), norm=clr.LogNorm(0.9995,1),cmap='bwr')        ax0.set_xlabel('X [kpc]')    ax0.set_ylabel('Z [kpc]')    ax1.set_xlabel('Y [kpc]')    ax1.set_ylabel('Z [kpc]')    ax0.set_xlim([-Rmax,Rmax])    ax1.set_xlim([Rmax,-Rmax])    for ax in [ax0,ax1]:        ax.set_ylim([-5,5])        # ax.legend(loc='upper right')    cbar = plt.colorbar(cm.ScalarMappable(norm=clr.LogNorm(0.9995,1), cmap='bwr'), ax=ax1)    cbar.ax.get_yaxis().labelpad = 15    cbar.ax.set_ylabel('|Lz/Ltot|', rotation=270)    plt.show()        gc = coord.SkyCoord(x=wstep.x[inds],                       y=wstep.y[inds],                       z=wstep.z[inds],                       frame=coord.Galactocentric)    gc = gc.transform_to(coord.Galactic)        # plt.figure(dpi=300,figsize=(3,3))    # plt.hist(np.abs(Lvec.z/Lvec.norm()).value,bins=np.linspace(0.995,1,100),    #          histtype='step',ec='k')    # plt.xlabel('Lz/Ltot')    # plt.yscale('log')    # plt.show()        # mask = (gc.distance<100*u.kpc) & (gc.distance>0*u.kpc)    # rm, rM = 10,100    # ls, zs = Angle(gc.l[(R>rm)&(R<rM)]), wstep.z.value[inds][(R>rm)&(R<rM)]    # ls = ls.wrap_at(180*u.deg)    # l_bins = np.linspace(-180,180,100)    # z_bins = np.zeros_like(l_bins)        # for i in range(len(l_bins)):    #     if i<len(l_bins)-1:    #         select = (ls.value>=l_bins[i])&(ls.value<=l_bins[i+1])    #     if i == len(l_bins)-1:    #         select = (ls.value>=l_bins[i-1])    #     # print(len(zs[select]))    #     z_bins[i] = np.mean(zs[select])        # ax = plt.gca()    # im = ax.scatter(ls,zs,s=.1,color=cm.get_cmap('cmr.gem')(minage/6e3))    # ax.invert_xaxis()        # fig = plt.figure(dpi=400,figsize=(5,5))    # ax = fig.add_subplot(projection='3d')    # # Grab some test data.    # rr, pp = np.meshgrid(np.linspace(3,Rmax,20),np.linspace(0,2*np.pi,100),indexing='ij')    # xx,yy = rr*np.cos(pp), rr*np.sin(pp)    # zz = powerlaw_warp(xx,yy,a,b,rw,phi)    # # Plot a basic wireframe.    # ax.plot_wireframe(xx, yy, zz, rstride=1, cstride=1,    #                   lw=.1, ec='k')    # z_cmap = sns.color_palette("coolwarm", as_cmap=True) #cm.get_cmap('cmr.redshift')    # z_norm = clr.Normalize(vmin=-2, vmax=2)    # ax.scatter(wstep.x, wstep.y, wstep.z,    #           color=z_cmap(z_norm(wstep.z.value)),    #           s=.1,alpha=0.5, marker=',')    # ax.xaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))    # ax.yaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))    # ax.zaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))    # ax.xaxis._axinfo["grid"]['color'] =  (1,1,1,0.1)    # ax.yaxis._axinfo["grid"]['color'] =  (1,1,1,0.1)      # ax.zaxis._axinfo["grid"]['color'] =  (1,1,1,0.1)    # ax.set_xlim([-Rmax,Rmax])    # ax.set_ylim([-Rmax,Rmax])    # ax.set_zlim([-Rmax,Rmax])    # ax.view_init(16,20+180)    # plt.show()# plt.figure(dpi=500)# mono_age_warp(4000,5000)# mono_age_warp(3000,4000)# mono_age_warp(2000,3000)# mono_age_warp(1000,2000)# mono_age_warp(0,5000)# ax=plt.gca()# plt.show()#%%def mono_age_movie(minage, maxage):        animate_step = 5        z_cmap = sns.color_palette("coolwarm", as_cmap=True) #cm.get_cmap('cmr.redshift')    z_norm = clr.Normalize(vmin=-1, vmax=1)    nstep = 5000    dt = 1    tind = np.arange(nstep)        # First, initialize conditions    Rmax = 25        def plot_timestep_3d(t,fig):        wstep = wlist[t]        nparticle = len(wstep.x)        current_agelist = np.array(agelist)[:nparticle]        inds = (current_agelist>=minage) & (current_agelist<=maxage)                plt.clf()        ax3d = fig.add_subplot(projection='3d')        ax3d.scatter(wstep.x[inds], wstep.y[inds], wstep.z[inds],                  color=z_cmap(z_norm(wstep.z[inds].value)),                  s=.1,alpha=0.8, marker=',')        ax3d.set_title('%.1f < Age [Gyr] < %.1f\n%d Myr' %(minage/1e3, maxage/1e3,t*dt))        ax3d.xaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))        ax3d.yaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))        ax3d.zaxis.set_pane_color((1.0, 1.0, 1.0, 0.0))        ax3d.xaxis._axinfo["grid"]['color'] =  (1,1,1,0.1)        ax3d.yaxis._axinfo["grid"]['color'] =  (1,1,1,0.1)          ax3d.zaxis._axinfo["grid"]['color'] =  (1,1,1,0.1)                ax3d.view_init(16,20+180)        ax3d.scatter(-8,0,0,s=10,marker="*",color='r',label='Sun')        ax3d.set_xlabel('X [kpc]')        ax3d.set_ylabel('Y [kpc]')        ax3d.set_zlabel('Z [kpc]')        ax3d.set_xlim([-Rmax,Rmax])        ax3d.set_ylim([-Rmax,Rmax])        ax3d.set_zlim([-Rmax,Rmax])        ax3d.legend()        return fig        def animate_3d(tid):        plt.clf()        plot_timestep_3d(tid, fig)        print(tid)        return fig    fig = plt.figure(dpi=300,figsize=(6,6))    ani = FuncAnimation(fig, animate_3d, frames=tind[0::animate_step], interval=100, repeat=False,                        cache_frame_data=False)    ani.save('warping_%d_%dGyr.gif'%(minage/1e3, maxage/1e3), writer=PillowWriter())        def plot_timestep_xyz(t,fig):        wstep = wlist[t]        nparticle = len(wstep.x)        current_agelist = np.array(agelist)[:nparticle]        inds = (current_agelist>=minage) & (current_agelist<=maxage)                plt.clf()        gs = GridSpec(1, 3, figure=fig,wspace=0.3)        ax0, ax1, ax2 = fig.add_subplot(gs[0]), fig.add_subplot(gs[1]), fig.add_subplot(gs[2])        # R = np.sqrt(wstep.x[inds]**2+ wstep.y[inds]**2).value        ax1.set_title('%.1f < Age [Gyr] < %.1f\n%d Myr' %(minage/1e3, maxage/1e3,t*dt))        ax0.scatter(wstep.x[inds], wstep.y[inds], s=.1, alpha=1, c=current_agelist[inds], cmap='cmr.torch_r', norm=clr.Normalize(vmin=0, vmax=5e3))        ax1.scatter(wstep.x[inds], wstep.z[inds], s=.1, alpha=1, c=current_agelist[inds], cmap='cmr.torch_r', norm=clr.Normalize(vmin=0, vmax=5e3))        ax2.scatter(wstep.y[inds], wstep.z[inds], s=.1, alpha=1, c=current_agelist[inds], cmap='cmr.torch_r', norm=clr.Normalize(vmin=0, vmax=5e3))                ax0.set_xlabel('X [kpc]')        ax0.set_aspect('equal')        ax1.set_xlabel('X [kpc]')        ax2.set_xlabel('Y [kpc]')        ax0.set_ylabel('Y [kpc]')        ax1.set_ylabel('Z [kpc]')        ax2.set_ylabel('Z [kpc]')        for ax in [ax0, ax1, ax2]:            ax.set_xlim([-Rmax, Rmax])            ax.set_ylim([-Rmax, Rmax])            ax.set_aspect('equal')        ax2.invert_xaxis()        plt.tight_layout()        return fig        def animate_xyz(tid):        plt.clf()        plot_timestep_xyz(tid, fig)        print(tid)        return fig    # fig = plt.figure(dpi=300,figsize=(19,6))    # ani = FuncAnimation(fig, animate_xyz, frames=tind[0::animate_step], interval=100, repeat=False,    #                     cache_frame_data=False)    # ani.save('warping_xyz_%d_%dGyr.gif'%(minage/1e3,maxage/1e3), writer=PillowWriter())        def plot_Lz(t,fig):        wstep = wlist[t]        nparticle = len(wstep.x)        current_agelist = np.array(agelist)[:nparticle]        inds = (current_agelist>=minage) & (current_agelist<=maxage)                Lvec = compute_Lvec(wstep)[inds]                plt.clf()        ax = plt.gca()        # R = np.sqrt(wstep.x[inds]**2+ wstep.y[inds]**2).value        ax.set_title('%.1f < Age [Gyr] < %.1f\n%d Myr' %(minage/1e3, maxage/1e3,t*dt))        ax.scatter( Lvec.z,np.abs(Lvec.z/Lvec.norm()), s=.1, alpha=1, c=current_agelist[inds], cmap='cmr.torch_r', norm=clr.Normalize(vmin=0, vmax=5e3))        ax.set_xlabel('Lz')        ax.set_ylabel('|Lz/Ltot|')        ax.set_xlim([0,-8])        ax.set_yscale('log')        ax.set_ylim([1,0.9991])        plt.tight_layout()        return fig        def animate_Lz(tid):        plt.clf()        plot_Lz(tid, fig)        print(tid)        return fig    # fig = plt.figure(dpi=300,figsize=(6,6))    # ani = FuncAnimation(fig, animate_Lz, frames=tind[0::animate_step], interval=100, repeat=False,    #                     cache_frame_data=False)    # ani.save('warping_Lz_%d_%dGyr.gif'%(minage/1e3,maxage/1e3), writer=PillowWriter())        pass# mono_age_movie(0,5000)# mono_age_movie(4000,5000)# %%def plot_both(minage,maxage, stick):    if stick=='Gas':        w0 = wlist[-1]        ind = (np.array(agelist) >= minage) & (np.array(agelist) <= maxage)        birthR = np.array(birthRlist)        age = np.array(agelist)/1000            if stick=='Stars':        w0 = wlist_nostick[-1]        ind = (np.array(agelist_nostick) >= minage) & (np.array(agelist_nostick) <= maxage)        birthR = np.array(birthRlist_nostick)        age = np.array(agelist_nostick)/1000    if stick=='No Tilt':        w0 = wlist_notilt[-1]        ind = (np.array(agelist_notilt) >= minage) & (np.array(agelist_notilt) <= maxage)        birthR = birthRlist_notilt            TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)    OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)    popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x[ind].value,w0.y[ind].value]).T,ydata=w0.z[ind].value,                           bounds=np.array([(0,10),(1,5),(0,1),(0,180)]).T)    phis = np.arctan2(w0.y[ind].value, w0.x[ind].value)    signs = np.where(np.abs(phis)<np.pi/2, 1, -1)    # signs = np.where((phis>np.radians(popt[-1]))|(phis<-(np.pi-np.radians(popt[-1]))), -1, 1)    # signs = np.where(w0.z[ind]<0, 1, -1)    # signs = np.where(np.abs(phis-np.radians(popt[-1]))<np.pi/3 ,\    #                     -1, 1)    deltaZ = w0.z[ind].value - TwoDwarp(np.vstack([w0.x[ind].value,w0.y[ind].value]).T,*popt)        fig=plt.figure(dpi=300, figsize=(5.,6))    gs = GridSpec(2,2,figure=fig, height_ratios=[2,1],width_ratios=[30,1],                  hspace=0.01, wspace=0.05)    ax0,ax1 = fig.add_subplot(gs[0,0]), fig.add_subplot(gs[1,0])    cax  = fig.add_subplot(gs[:,1])        # ax0.set_title(stick+'\n%d < Age [Myr] < %d' %(minage, maxage))    # ax0.set_title(stick, fontsize=15)    # im=ax0.scatter(w0.x[ind],w0.z[ind], s=.1, c=np.array(birthR)[ind],    #             cmap='bwr', norm=clr.Normalize(0,16))    cmap = 'RdBu_r'    crange = 0,16    # crange = -0.1,5    im=ax0.scatter(signs*compute_R(w0[ind]),w0.z[ind],  c= birthR[ind],    # im=ax0.scatter(signs*compute_R(w0[ind]),w0.z[ind],  c= age[ind],                cmap=cmap, norm=clr.Normalize(*crange), s=birthR[ind]**2/100,                marker='o', facecolor='none', alpha=(1-age[ind]/5e3)*0.5+0.5,                ec='w',lw=0.01)    ax0.set_xlim([-20,20])    ax0.set_ylim([-2,2])    ax0.set_xticks([])    ax0.set_yticks([-1.5,-1,-0.5,0,0.5,1,1.5])    # ax0.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),*popt),    #         lw=0.5, ls='dashed', c='k', label=r'$\Delta Z \propto Z_{20} (r-r_w)^{b}$'+'\n'+r'$Z_{20}$'+' = %.1f kpc, b=%.1f, '%(popt[0]*(20-popt[2])**popt[1],popt[1])+r'$r_w$'+'=%.1f kpc'%(popt[2]),    #         alpha=0.8)    ax0.set_ylabel(r'Z [kpc]', fontsize=12)    ax1.scatter(signs*compute_R(w0[ind]), deltaZ,                c= birthR[ind],                # c = age[ind],                cmap=cmap, norm=clr.Normalize(*crange), s=birthR[ind]**2/100,                marker='o', facecolor='none', alpha=(1-age[ind]/5e3)*0.5+0.5,                ec='w',lw=0.01)    ax1.set_xlim([-20,20])    ax1.set_ylim([-1.5,1.5])    ax1.set_ylabel(r'Z - Z$_{warp}$ [kpc]', fontsize=12)    ax1.set_xlabel(r'R [kpc]', fontsize=12)    ax1.set_yticks([-1,0,1])    cbar = fig.colorbar(im,cax=cax)    plt.ylim(0,16)    # plt.ylim(0,5)    cbar.ax.get_yaxis().labelpad = 15    cbar.ax.set_ylabel('Birth R [kpc]', rotation=270,fontsize=15,labelpad=20)    # cbar.ax.set_ylabel('Age [Gyr]', rotation=270, fontsize=11,labelpad=15)    plt.savefig(folder+'stars_birthR.pdf')    plt.show()    passplot_both(0,5000, 'Stars')# plot_both(0,5000, 'Gas')# plot_both(0,5000, 'All')#%%def plot_both_stargas(minage,maxage):    w0_2 = wlist[-1]    ind_2 = (np.array(agelist) >= minage) & (np.array(agelist) <= maxage)    birthR_2 = np.array(birthRlist)    age_2 = np.array(agelist)/1000        w0_1 = wlist_nostick[-1]    ind_1 = (np.array(agelist_nostick) >= minage) & (np.array(agelist_nostick) <= maxage)    birthR_1 = np.array(birthRlist_nostick)    age_1 = np.array(agelist_nostick)/1000            TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)    OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)        fig=plt.figure(dpi=500, figsize=(12.,6))    gs = GridSpec(2,3,figure=fig, height_ratios=[2,1],width_ratios=[30,30,1],                  hspace=0.01, wspace=0.05)    ax0,ax1 = fig.add_subplot(gs[0,0]), fig.add_subplot(gs[1,0])    ax2,ax3 = fig.add_subplot(gs[0,1]), fig.add_subplot(gs[1,1])    cax  = fig.add_subplot(gs[:,2])    ax0.set_title("Stars", fontsize=15)    ax2.set_title("Gas", fontsize=15)    cmap = 'RdBu_r'    # cmap = 'cmr.voltage_r'    crange = -0.1,5.5        # Plot stars    popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0_1.x[ind_1].value,w0_1.y[ind_1].value]).T,ydata=w0_1.z[ind_1].value,                           bounds=np.array([(0,10),(1,5),(0,1),(0,180)]).T)    phis = np.arctan2(w0_1.y[ind_1].value, w0_1.x[ind_1].value)    signs = np.where(np.abs(phis)<np.pi/2, 1, -1)    deltaZ = w0_1.z[ind_1].value - TwoDwarp(np.vstack([w0_1.x[ind_1].value,w0_1.y[ind_1].value]).T,*popt)    im=ax0.scatter(signs*compute_R(w0_1[ind_1]),w0_1.z[ind_1],  c= age_1[ind_1],                cmap=cmap, norm=clr.Normalize(*crange), s=compute_R(w0_1[ind_1])**2/100,                marker='o', facecolor='none', alpha=1,#(1-age_1[ind_1]/5e3)*0.5+0.5,                ec='w',lw=0.01)    ax0.set_xlim([-20,20])    ax0.set_ylim([-2,2])    ax0.set_xticks([])    ax0.set_yticks([-1.5,-1,-0.5,0,0.5,1,1.5])    ax0.set_ylabel(r'Z [kpc]')    ax1.scatter(signs*compute_R(w0_1[ind_1]), deltaZ,                c = age_1[ind_1],                cmap=cmap, norm=clr.Normalize(*crange), s=compute_R(w0_1[ind_1])**2/100,                marker='o', facecolor='none', alpha=(1-age_1[ind_1]/5e3)*0.5+0.5,                ec='w',lw=0.01)    ax1.set_xlim([-20,20])    ax1.set_ylim([-1.5,1.5])    ax1.set_ylabel(r'Z - Z$_{warp}$ [kpc]')    ax1.set_xlabel(r'R [kpc]')    ax1.set_yticks([-1,0,1])    cbar = fig.colorbar(im,cax=cax)    # plt.ylim(0,16)    plt.ylim(0,5)    cbar.ax.get_yaxis().labelpad = 15    cbar.ax.set_ylabel('Age [Gyr]', rotation=270, fontsize=11,labelpad=15)        # Plot Gas    popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0_2.x[ind_2].value,w0_2.y[ind_2].value]).T,ydata=w0_2.z[ind_2].value,                           bounds=np.array([(0,10),(1,5),(0,1),(0,180)]).T)    phis = np.arctan2(w0_2.y[ind_2].value, w0_2.x[ind_2].value)    signs = np.where(np.abs(phis)<np.pi/2, 1, -1)    deltaZ = w0_2.z[ind_2].value - TwoDwarp(np.vstack([w0_2.x[ind_2].value,w0_2.y[ind_2].value]).T,*popt)    im=ax2.scatter(signs*compute_R(w0_2[ind_2]),w0_2.z[ind_2],  c=age_2[ind_2],                cmap=cmap, norm=clr.Normalize(*crange), s=compute_R(w0_2[ind_2])**2/100,                marker='o', facecolor='none', alpha=(1-age_2[ind_2]/5e3)*0.5+0.5,                ec='w',lw=0.01)    ax2.set_xlim([-20,20])    ax2.set_ylim([-2,2])    ax2.set_xticks([])    ax3.scatter(signs*compute_R(w0_2[ind_2]), deltaZ,                c = age_2[ind_2],                cmap=cmap, norm=clr.Normalize(*crange), s=compute_R(w0_2[ind_2])**2/100,                marker='o', facecolor='none', alpha=(1-age_2[ind_2]/5e3)*0.5+0.5,                ec='w',lw=0.01)    ax3.set_xlim([-20,20])    ax3.set_ylim([-1.5,1.5])    ax3.set_xlabel(r'R [kpc]')    ax2.set_yticks([])    ax3.set_yticks([])    ax3.set_xticks([-10,0,10,20])        plt.show()    # plot_both_stargas(0,5000)# %%outer_hi = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/HI_W90.csv',                      names=['R','z'])outer_hi['z'] = outer_hi['z']/1000outer_hi['R'] = outer_hi['R']*(8.18/8.5)inner_hi = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/inner_hi.csv',                      names=['R','z'])inner_hi['R'] = inner_hi['R']*(8.18/8.5)# hi_flare = pd.concat([inner_hi, outer_hi])# hi_flare = outer_hihi_flare =  pd.concat([inner_hi,pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/l06_flare.csv',                      names=['R','z'])])ceph_flare = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/cepheids.csv',                      names=['R','z'])hi_north = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/HI_north.csv',                      names=['R','z'])hi_south = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/HI_south.csv',                      names=['R','z'])ceph_north = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/cepheids_north.csv',                      names=['R','z'])ceph_south = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/cepheids_south.csv',                      names=['R','z'])def plot_lit_v2(minage,maxage, stick):    if stick=='Gas':        w0 = wlist[-1]        ind = (np.array(agelist) >= minage) & (np.array(agelist) <= maxage)        birthR = birthRlist        data_north = hi_north        data_south = hi_south        data_flare = hi_flare        data_name = 'Observed Gas (Levine 06)'        # data_color = 'xkcd:cornflower blue'        data_color = 'k'        model_color = 'b'        rw_start = 10        birthR = birthRlist        age = agelist            if stick=='Stars':        w0 = wlist_nostick[-1]        ind = (np.array(agelist_nostick) >= minage) & (np.array(agelist_nostick) <= maxage)        birthR = birthRlist_nostick        data_north = ceph_north        data_south = ceph_south        data_flare = ceph_flare        data_name = 'Observed Stars (Chen 19)'        # data_color = 'xkcd:rose'        data_color='k'        model_color= 'r'        rw_start = 8        birthR = birthRlist_nostick        age = agelist_nostick            TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)    OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)    popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x[ind].value,w0.y[ind].value]).T,ydata=w0.z[ind].value,                            bounds=np.array([(0,10),(0.5,10),(0,1),(0,180)]).T)    phis = np.arctan2(w0.y[ind].value, w0.x[ind].value)    signs = np.where(np.abs(phis )<np.pi/2, 1, -1)    # signs = np.where((phis>np.radians(popt[-1]))|(phis<-(np.pi-np.radians(popt[-1]))), -1, 1)        a_unc, b_unc = np.sqrt(pcov[0,0]), np.sqrt(pcov[1,1])    deltaZ = w0.z[ind].value - TwoDwarp(np.vstack([w0.x[ind].value,w0.y[ind].value]).T,*popt)    # deltaZ = np.abs(w0.z[ind].value)        fig=plt.figure(dpi=500, figsize=(5.,6))    gs = GridSpec(2,2,figure=fig, height_ratios=[2,1],width_ratios=[30,1],                  hspace=0)    ax0,ax2 = fig.add_subplot(gs[0,0]), fig.add_subplot(gs[1,0])    # cax  = fig.add_subplot(gs[:,1])        # ax0.scatter(compute_R(w0[ind][signs<0]),w0.z[ind][signs<0], s=.1, c=np.array(birthR)[ind][signs<0],    #             cmap='bwr', norm=clr.Normalize(0,16))    im=ax0.scatter(signs*compute_R(w0[ind]),w0.z[ind], s=.1, c='grey',                   # c=np.array(birthR)[ind],                   # cmap='bwr', norm=clr.Normalize(0,16),                   alpha=0.1,)    im = ax2.scatter(signs*compute_R(w0[ind]),deltaZ, s=0.1, c='grey', alpha=0.2)    ax0.set_title(stick, fontsize=15)    ax0.plot(-data_north['R'], data_north['z'], c=data_color,lw=0.7,ls='--')    ax0.plot(data_south['R'], data_south['z'], c=data_color,lw=0.7, ls='--')    ax0.set_xlim([-20,20])    ax0.set_ylim([-2,2])    ax0.set_xticks([])    ax0.set_yticks([-1.5,-1,-0.5,0,0.5,1,1.5])    ax0.text(s='--- '+data_name, x=-18,y=-1.5)    # ax0.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),*popt),    #         lw=1, ls='dashed', c='k',     #         label='This Work (Han 23)',    #         alpha=1)        ax0.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),popt[0],popt[1],popt[2],90),            lw=1, ls='solid', c=model_color,             # label=r'$\Delta Z \propto Z_{20} (r-r_w)^{b}$'+'\n'+r'$Z_{20}$'+' = %.1f kpc, b=%.1f, '%(popt[0]*(20-popt[2])**popt[1],popt[1])+r'$r_w$'+'=%.1f kpc'%(popt[2]),            label='Fiducial Fit (Han 23)',            alpha=1)        sigma_plot = 1.    ax0.fill_between(np.linspace(-20,20,100),                     OneDwarp(np.linspace(-20,20,100),popt[0]+sigma_plot*a_unc,popt[1]+sigma_plot*b_unc,popt[2],90),                     OneDwarp(np.linspace(-20,20,100),popt[0]-sigma_plot*a_unc,popt[1]-sigma_plot*b_unc,popt[2],90),                     fc=model_color, alpha=0.1)        dr = 2    r_bins = np.arange(0,20,0.1)    scales = []    scale_unc = []    for r in r_bins:        data = np.abs(deltaZ[(compute_R(w0[ind])>=r)&(compute_R(w0[ind])<=(r+dr))& (np.abs(deltaZ)<2)])        # loc, scale = expon.fit(data)        scalelist = []        for rand_sample in [np.random.choice(data,size=10) for i in range(100)]:            loc, scale = expon.fit(rand_sample)            scalelist.append(scale)        scale = np.mean(scalelist)        unc = np.std(scalelist)        scales.append(scale)        scale_unc.append(unc)        scales = np.array(scales)    # scales = medfilt(scales,7)    scale_unc = np.array(scale_unc)    scale_fn = lambda x, a, b, c: a + x*b + c*x**2 #a*(np.exp(x/b)-1)    # scale_fn = lambda x, a, b: a*(np.exp(x/b)-1)    popt, pcov = curve_fit(scale_fn, r_bins, scales, sigma=scale_unc, absolute_sigma=True)    # scale_unc = medfilt(scale_unc,3)        ax2.plot(data_flare['R'], data_flare['z'], lw=0.7, c=data_color, ls='--')    ax2.plot(data_flare['R'], -data_flare['z'], lw=0.7, c=data_color, ls='--')    ax2.plot(-data_flare['R'], data_flare['z'], lw=0.7, c=data_color, ls='--')    ax2.plot(-data_flare['R'], -data_flare['z'], lw=0.7, c=data_color, ls='--')    ax2.set_yticks([-1,0,1])    # ax2.text(1, -0.8, 'Flare')    ax2.set_xlim([-20,20])    ax2.set_ylim([-1.5,1.5])    ax2.set_ylabel(r'$Z - Z_{warp}$ [kpc]')    ax2.set_xlabel(r'$R$ [kpc]')    ax2.plot(r_bins, scale_fn(r_bins, *popt), lw=1, c=model_color)    ax2.fill_between(r_bins, scale_fn(r_bins, *popt)-scale_unc,                      scale_fn(r_bins, *popt)+scale_unc,                      fc=model_color,alpha=0.1)    ax2.plot(r_bins, -scale_fn(r_bins, *popt), lw=1, c=model_color)    ax2.fill_between(r_bins, -scale_fn(r_bins, *popt)-scale_unc,                      -scale_fn(r_bins, *popt)+scale_unc,                      fc=model_color,alpha=0.1)    ax2.plot(-r_bins, scale_fn(r_bins, *popt), lw=1, c=model_color)    ax2.fill_between(-r_bins, scale_fn(r_bins, *popt)-scale_unc,                      scale_fn(r_bins, *popt)+scale_unc,                      fc=model_color,alpha=0.1)    ax2.plot(-r_bins, -scale_fn(r_bins, *popt), lw=1, c=model_color)    ax2.fill_between(-r_bins, -scale_fn(r_bins, *popt)-scale_unc,                      -scale_fn(r_bins, *popt)+scale_unc,                      fc=model_color,alpha=0.1)        popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x[ind].value,w0.y[ind].value]).T,ydata=w0.z[ind].value,                            bounds=np.array([(0,10),(1,5),(0,rw_start),(0,360)]).T)    ax0.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),popt[0],popt[1],popt[2],90),            lw=0.7, ls='dashed', c=model_color,             label='Restricted Fit (Han 23)',            alpha=1)    ax0.set_ylabel(r'$Z$ [kpc]')    ax0.legend(loc='upper right', frameon=False)        plt.show()    passplot_lit_v2(0,5000,'Stars')plot_lit_v2(0,5000,'Gas')#%%chen_data = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/chen19_data.txt', sep='\s+',skiprows=33,                        names=['ra','dec','glon','glat','per','dist','e_dist'], usecols=[0,1,2,3,4,5,6])c = coord.SkyCoord(ra=chen_data['ra'] * u.degree,                   dec=chen_data['dec'] * u.degree,                    distance=chen_data['dist'] * u.kpc,                   frame='icrs')c = c.transform_to(coord.Galactocentric(galcen_distance=8*u.kpc)) chen_data['X'] = c.x.valuechen_data['Y'] = c.y.valuechen_data['Z'] = c.z.valuedef plot_lit_stargas(minage,maxage):    w0_2 = wlist[-1]    ind_2 = (np.array(agelist) >= minage) & (np.array(agelist) <= maxage)    birthR_2 = np.array(birthRlist)    age_2 = np.array(agelist)/1000    rw_start_2 = 8.5    w0_1 = wlist_nostick[-1]    ind_1 = (np.array(agelist_nostick) >= minage) & (np.array(agelist_nostick) <= maxage)    birthR_1 = np.array(birthRlist_nostick)    age_1 = np.array(agelist_nostick)/1000    rw_start_1 =  8.5        TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)    OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)    popt_1, pcov_1 = curve_fit(TwoDwarp, xdata=np.vstack([w0_1.x[ind_1].value,w0_1.y[ind_1].value]).T,                               ydata=w0_1.z[ind_1].value,                               bounds=np.array([(0,10),(1,5),(0,rw_start_1),(0,180)]).T)    phis_1 = np.arctan2(w0_1.y[ind_1].value, w0_1.x[ind_1].value)    # signs_1 = np.where(np.abs(phis_1)<np.pi/2, 1, -1)    signs_1 = np.where( np.sin(phis_1- np.radians(popt_1[-1]))<0 ,1,-1)    deltaZ_1 = w0_1.z[ind_1].value - TwoDwarp(np.vstack([w0_1.x[ind_1].value,w0_1.y[ind_1].value]).T,*popt_1)    a_unc_1, b_unc_1 = np.sqrt(pcov_1[0,0]), np.sqrt(pcov_1[1,1])        popt_2, pcov_2 = curve_fit(TwoDwarp, xdata=np.vstack([w0_2.x[ind_2].value,w0_2.y[ind_2].value]).T,                               ydata=w0_2.z[ind_2].value,                               bounds=np.array([(0,10),(1,5),(0,rw_start_2),(0,180)]).T)    a_unc_2, b_unc_2 = np.sqrt(pcov_2[0,0]), np.sqrt(pcov_2[1,1])    phis_2 = np.arctan2(w0_2.y[ind_2].value, w0_2.x[ind_2].value)    signs_2 = np.where(np.abs(phis_2)<np.pi/2, 1, -1)    deltaZ_2 = w0_2.z[ind_2].value - TwoDwarp(np.vstack([w0_2.x[ind_2].value,w0_2.y[ind_2].value]).T,*popt_2)        fig=plt.figure(dpi=500, figsize=(10,6))    gs = GridSpec(2,2,figure=fig, height_ratios=[2,1],width_ratios=[1,1],                  hspace=0., wspace=0.1)    ax0,ax1 = fig.add_subplot(gs[0,0]), fig.add_subplot(gs[1,0])    ax2,ax3 = fig.add_subplot(gs[0,1]), fig.add_subplot(gs[1,1])    # im=ax0.scatter(signs_1*compute_R(w0_1[ind_1]),w0_1.z[ind_1], s=.1, c='grey',                    # alpha=0.1,)     # ax0.scatter( np.sqrt(chen_data['X']**2 + chen_data['Y']**2) * np.where( np.sin(np.arctan2(chen_data['Y'],chen_data['X'])- np.radians(17.5))<0 ,1,-1) ,                # chen_data['Z'], s=.1,c='grey',alpha=0.3 )    # ax1.scatter(np.sqrt(chen_data['X']**2 + chen_data['Y']**2) * np.where( np.sin(np.arctan2(chen_data['Y'],chen_data['X'])- np.radians(17.5))<0 ,1,-1),    #             chen_data['Z'] - TwoDwarp(np.vstack([chen_data['X'], chen_data['Y']]).T, popt_1[0], popt_1[1], popt_1[2], 0),    #             s=0.1, c='grey', alpha=0.3)        # ax0.set_title('Stars', fontsize=15)    # ax0.plot(-ceph_north['R'], ceph_north['z'], c='k',lw=0.7,ls='--')    # ax0.plot(ceph_south['R'], ceph_south['z'], c='k',lw=0.7, ls='--')        # ax0.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),0.06,1.33,7.72,17.5+90),    #          c='k',lw=0.7,ls='--')    ceph_grid = np.linspace(-20,20,40)[np.abs(np.linspace(-20,20,40))>8]     ax0.scatter(ceph_grid, OneDwarp(ceph_grid,0.06,1.33,7.72,17.5+90),             facecolor='none', s=10, lw=0.5, edgecolor='k')        ax0.set_xlim([-20,20])    ax0.set_ylim([-2,2])    ax0.set_xticks([])    ax0.set_yticks([-1.5,-1,-0.5,0,0.5,1,1.5])    ax0.text(s=r'$\circ$ Cepheids', x=-18,y=-1.5)    # ax0.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),*popt),    #         lw=1, ls='dashed', c='k',     #         label='This Work (Han 23)',    #         alpha=1)        ax0.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),popt_1[0],popt_1[1],popt_1[2],90),            lw=1, ls='solid', c='r',             # label=r'$\Delta Z \propto Z_{20} (r-r_w)^{b}$'+'\n'+r'$Z_{20}$'+' = %.1f kpc, b=%.1f, '%(popt[0]*(20-popt[2])**popt[1],popt[1])+r'$r_w$'+'=%.1f kpc'%(popt[2]),            label='Disk Stars in Tilted Dark Halo',            alpha=1)        sigma_plot = 1.    ax0.fill_between(np.linspace(-20,20,100),                     OneDwarp(np.linspace(-20,20,100),popt_1[0]+sigma_plot*a_unc_1,popt_1[1]+sigma_plot*b_unc_1,popt_1[2],90),                     OneDwarp(np.linspace(-20,20,100),popt_1[0]-sigma_plot*a_unc_1,popt_1[1]-sigma_plot*b_unc_1,popt_1[2],90),                     fc='xkcd:cherry', alpha=0.3)        dr = 2    r_bins = np.arange(0,20,0.1)    scales = []    scale_unc = []    for r in r_bins:        data = np.abs(deltaZ_1[(compute_R(w0_1[ind_1])>=r)&(compute_R(w0_1[ind_1])<=(r+dr))& (np.abs(deltaZ_1)<2)])        # loc, scale = expon.fit(data)        scalelist = []        for rand_sample in [np.random.choice(data,size=10) for i in range(100)]:            loc, scale = expon.fit(rand_sample)            scalelist.append(scale)        scale = np.mean(scalelist)        unc = np.std(scalelist)        scales.append(scale)        scale_unc.append(unc)        scales = np.array(scales)    # scales = medfilt(scales,7)    scale_unc = np.array(scale_unc)    scale_fn = lambda x, a, b, c: a + x*b + c*x**2 #a*(np.exp(x/b)-1)    popt, pcov = curve_fit(scale_fn, r_bins, scales, sigma=scale_unc, absolute_sigma=True)        ax1.plot(ceph_flare['R'], ceph_flare['z'], lw=0.7, c='k', ls='--')    ax1.plot(ceph_flare['R'], -ceph_flare['z'], lw=0.7, c='k', ls='--')    ax1.plot(-ceph_flare['R'], ceph_flare['z'], lw=0.7, c='k', ls='--')    ax1.plot(-ceph_flare['R'], -ceph_flare['z'], lw=0.7, c='k', ls='--',             label='Cepheids')    ax1.legend(loc='upper left', frameon=False)    ax1.set_yticks([-1,0,1])    ax1.set_xlim([-20,20])    ax1.set_ylim([-1.5,1.5])    ax1.set_ylabel(r'Z - Z$_{warp}$ [kpc]', fontsize=12)    ax1.set_xlabel('R [kpc]', fontsize=12)    ax1.plot(r_bins, scale_fn(r_bins, *popt), lw=1, c='r')    ax1.fill_between(r_bins, scale_fn(r_bins, *popt)-scale_unc,                      scale_fn(r_bins, *popt)+scale_unc,                      fc='r',alpha=0.3)    ax1.plot(r_bins, -scale_fn(r_bins, *popt), lw=1, c='r')    ax1.fill_between(r_bins, -scale_fn(r_bins, *popt)-scale_unc,                      -scale_fn(r_bins, *popt)+scale_unc,                      fc='r',alpha=0.3)    ax1.plot(-r_bins, scale_fn(r_bins, *popt), lw=1, c='r')    ax1.fill_between(-r_bins, scale_fn(r_bins, *popt)-scale_unc,                      scale_fn(r_bins, *popt)+scale_unc,                      fc='r',alpha=0.3)    ax1.plot(-r_bins, -scale_fn(r_bins, *popt), lw=1, c='r')    ax1.fill_between(-r_bins, -scale_fn(r_bins, *popt)-scale_unc,                      -scale_fn(r_bins, *popt)+scale_unc,                      fc='r',alpha=0.3)        popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0_1.x[ind_1].value,w0_1.y[ind_1].value]).T,ydata=w0_1.z[ind_1].value,                            bounds=np.array([(0,10),(1,5),(0,rw_start_1),(0,360)]).T)    # ax0.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),popt[0],popt[1],popt[2],90),    #         lw=0.7, ls='dashed', c='r',     #         label='Restricted Fit (Han 23)',    #         alpha=1)    ax0.set_ylabel('Z [kpc]', fontsize=12)    ax0.legend(loc='upper right', frameon=False, fontsize=12)        # im=ax2.scatter(signs_2*compute_R(w0_2[ind_2]),w0_2.z[ind_2], s=.1, c='grey',                   # alpha=0.1,)    # ax3.scatter(signs_2*compute_R(w0_2[ind_2]),deltaZ_2, s=0.1, c='grey', alpha=0.2)    # ax2.set_title('Gas', fontsize=15)    # ax2.plot(-hi_north['R'], hi_north['z'], c='k',lw=0.7,ls='--')    # ax2.plot(hi_south['R'], hi_south['z'], c='k',lw=0.7, ls='--')        params = pd.read_csv('/Users/jhan/Science/Theory/Disk Tilting/code/kalberla.txt',names=['R','w0','w1','w2','phi_1','phi_2'],sep='\s+')    params['R'] = params['R'] * (8/8.5)    phi_grid = np.array([0, np.pi])    for phi in phi_grid:        ax2.scatter(params['R'] * np.where(np.cos(phi)>0, 1,-1),                    params['w0']+params['w1']*np.sin(phi-np.radians(params['phi_1'])) +params['w2']*np.sin(2*phi - np.radians(params['phi_2'])),                    facecolor='none', s=10, lw=0.5, edgecolor='k')        ax2.set_xlim([-20,20])    ax2.set_ylim([-2,2])    ax2.text(s=r'$\circ$ '+'HI', x=-18,y=-1.5)    ax2.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),popt_2[0],popt_2[1],popt_2[2],90),            lw=1, ls='solid', c='b',             # label=r'$\Delta Z \propto Z_{20} (r-r_w)^{b}$'+'\n'+r'$Z_{20}$'+' = %.1f kpc, b=%.1f, '%(popt[0]*(20-popt[2])**popt[1],popt[1])+r'$r_w$'+'=%.1f kpc'%(popt[2]),            label='Disk Gas in Tilted Dark Halo',            alpha=1)        sigma_plot = 1.    ax2.fill_between(np.linspace(-20,20,100),                     OneDwarp(np.linspace(-20,20,100),popt_2[0]+sigma_plot*a_unc_2,popt_2[1]+sigma_plot*b_unc_2,popt_2[2],90),                     OneDwarp(np.linspace(-20,20,100),popt_2[0]-sigma_plot*a_unc_2,popt_2[1]-sigma_plot*b_unc_2,popt_2[2],90),                     fc='xkcd:cornflower blue', alpha=0.3)    dr = 2    r_bins = np.arange(0,20,0.1)    scales = []    scale_unc = []    for r in r_bins:        data = np.abs(deltaZ_2[(compute_R(w0_2[ind_2])>=r)&(compute_R(w0_2[ind_2])<=(r+dr))& (np.abs(deltaZ_2)<2)])        scalelist = []        for rand_sample in [np.random.choice(data,size=10) for i in range(100)]:            loc, scale = expon.fit(rand_sample)            scalelist.append(scale)        scale = np.mean(scalelist)        unc = np.std(scalelist)        scales.append(scale)        scale_unc.append(unc)        scales = np.array(scales)    # scales = medfilt(scales,7)    scale_unc = np.array(scale_unc)    scale_fn = lambda x, a, b, c: a + x*b + c*x**2 #a*(np.exp(x/b)-1)    popt, pcov = curve_fit(scale_fn, r_bins, scales, sigma=scale_unc, absolute_sigma=True)        ax3.plot(hi_flare['R'], hi_flare['z'], lw=0.7, c='k', ls='--')    ax3.plot(hi_flare['R'], -hi_flare['z'], lw=0.7, c='k', ls='--')    ax3.plot(-hi_flare['R'], hi_flare['z'], lw=0.7, c='k', ls='--')    ax3.plot(-hi_flare['R'], -hi_flare['z'], lw=0.7, c='k', ls='--',             label='HI')    ax3.set_yticks([-1,0,1])    ax3.set_xlim([-20,20])    ax3.set_ylim([-1.5,1.5])    ax3.legend(loc='upper left', frameon=False)    ax3.set_xlabel('R [kpc]', fontsize=12)    ax3.plot(r_bins, scale_fn(r_bins, *popt), lw=1, c='b')    ax3.fill_between(r_bins, scale_fn(r_bins, *popt)-scale_unc,                      scale_fn(r_bins, *popt)+scale_unc,                      fc='xkcd:cornflower blue',alpha=0.3)    ax3.plot(r_bins, -scale_fn(r_bins, *popt), lw=1, c='b')    ax3.fill_between(r_bins, -scale_fn(r_bins, *popt)-scale_unc,                      -scale_fn(r_bins, *popt)+scale_unc,                      fc='xkcd:cornflower blue',alpha=0.3)    ax3.plot(-r_bins, scale_fn(r_bins, *popt), lw=1, c='b')    ax3.fill_between(-r_bins, scale_fn(r_bins, *popt)-scale_unc,                      scale_fn(r_bins, *popt)+scale_unc,                      fc='xkcd:cornflower blue',alpha=0.3)    ax3.plot(-r_bins, -scale_fn(r_bins, *popt), lw=1, c='b')    ax3.fill_between(-r_bins, -scale_fn(r_bins, *popt)-scale_unc,                      -scale_fn(r_bins, *popt)+scale_unc,                      fc='xkcd:cornflower blue',alpha=0.3)        popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0_1.x[ind_1].value,w0_1.y[ind_1].value]).T,ydata=w0_1.z[ind_1].value,                            bounds=np.array([(0,10),(1,5),(0,rw_start_2),(0,360)]).T)    # ax2.plot(np.linspace(-20,20,100), OneDwarp(np.linspace(-20,20,100),popt[0],popt[1],popt[2],90),    #         lw=0.7, ls='dashed', c='b',     #         label='Restricted Fit (Han 23)',    #         alpha=1)    ax2.legend(loc='upper right', frameon=False, fontsize=12)    ax3.legend(loc='upper right', frameon=False)        ax2.set_yticks([])    ax2.set_xticks([])    ax3.set_yticks([])    ax3.set_xticks([-20, -10,0,10,20])    plt.savefig('lit_compare.pdf')    plt.show()    passplot_lit_stargas(0,5000) #%%def plot_lit_both(minage,maxage):    fig=plt.figure(dpi=400, figsize=(6.,7))    gs = GridSpec(3,2,figure=fig, height_ratios=[2,2,1],width_ratios=[30,1],                  hspace=0)    ax0,ax1,ax2 = fig.add_subplot(gs[0,0]), fig.add_subplot(gs[1,0]), fig.add_subplot(gs[2,0])    def plot_one(stick):        if stick=='Gas':            w0 = wlist[-1]            ind = (np.array(agelist) >= minage) & (np.array(agelist) <= maxage)            birthR = birthRlist            TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)            OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)            popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x[ind].value,w0.y[ind].value]).T,ydata=w0.z[ind].value,                                   bounds=np.array([(0,10),(1,5),(0,10),(0,360)]).T)            phis = np.arctan2(w0.y[ind].value, w0.x[ind].value)            signs = np.where(np.abs(phis)<np.pi/2, 1, -1)                        deltaZ = w0.z[ind].value - TwoDwarp(np.vstack([w0.x[ind].value,w0.y[ind].value]).T,*popt)            ax2.plot(hi_flare['R'], hi_flare['z'], lw=1, c='xkcd:cornflower blue', ls='dashed')            ax2.plot(hi_flare['R'], -hi_flare['z'], lw=1, c='xkcd:cornflower blue', ls='dashed')            ax0.plot(hi_north['R'], hi_north['z'], c='xkcd:cornflower blue',lw=1,                     label='HI (Levine 06)',ls='dashed')            ax0.plot(np.linspace(0,20,100), OneDwarp(np.linspace(0,20,100),popt[0],popt[1],popt[2],-90),                    lw=1, ls='solid', c='b',                     # label=r'$\Delta Z \propto Z_{20} (r-r_w)^{b}$'+'\n'+r'$Z_{20}$'+' = %.1f kpc, b=%.1f, '%(popt[0]*(20-popt[2])**popt[1],popt[1])+r'$r_w$'+'=%.1f kpc'%(popt[2]),                    label='Gas in Tilted Halo (Han 23)',                    alpha=1)            ax1.plot(hi_south['R'], hi_south['z'], c='xkcd:cornflower blue',lw=1,ls='dashed')            ax1.plot(np.linspace(0,20,100), OneDwarp(np.linspace(0,20,100),popt[0],popt[1],popt[2],90),                    lw=1, ls='solid', c='b', label=r'$\Delta Z \propto Z_{20} (r-r_w)^{b}$'+'\n'+r'$Z_{20}$'+' = %.1f kpc, b=%.1f, '%(popt[0]*(20-popt[2])**popt[1],popt[1])+r'$r_w$'+'=%.1f kpc'%(popt[2]),                    alpha=1)                                dr= 4            r_bins = np.arange(0,20,0.1)            scales = []            for r in r_bins:                data = np.abs(deltaZ[(compute_R(w0[ind])>=r)&(compute_R(w0[ind])<=(r+dr))& (np.abs(deltaZ)<2)])                loc, scale = expon.fit(data)                scales.append(scale)            scales = np.array(scales)            im = ax2.scatter(compute_R(w0[ind]), deltaZ, s=0.1, c='k', alpha=0.2)            ax2.set_yticks([-0.5,0,0.5])            ax2.text(1, -0.8, 'Flare')            ax2.set_xlim([0,20])            ax2.set_ylim([-1.2,1.2])            ax2.set_ylabel(r'$|Z - Z_{warp}|$')            ax2.set_xlabel(r'$R$ [kpc]')            ax2.plot(r_bins, scales, lw=1, ls='-',c='b')            ax2.plot(r_bins, -scales, lw=1, ls='-',c='b')                            if stick=='Stars':            w0 = wlist_nostick[-1]            ind = (np.array(agelist_nostick) >= minage) & (np.array(agelist_nostick) <= maxage)            birthR = birthRlist_nostick            TwoDwarp = lambda pos,a,b,rw,phi_w: powerlaw_warp(pos[:,0], pos[:,1],a,b,rw,phi_w)            OneDwarp = lambda r, a,b,rw,phi_w: powerlaw_warp(r, 0,a,b,rw,phi_w)            popt, pcov = curve_fit(TwoDwarp, xdata=np.vstack([w0.x[ind].value,w0.y[ind].value]).T,ydata=w0.z[ind].value,                                   bounds=np.array([(0,10),(1,5),(0,10),(0,360)]).T)            phis = np.arctan2(w0.y[ind].value, w0.x[ind].value)            signs = np.where(np.abs(phis)<np.pi/2, 1, -1)                        deltaZ = w0.z[ind].value - TwoDwarp(np.vstack([w0.x[ind].value,w0.y[ind].value]).T,*popt)            ax2.plot(ceph_flare['R'], ceph_flare['z'], lw=1, c='xkcd:rose', ls='dashed')            ax2.plot(ceph_flare['R'], -ceph_flare['z'], lw=1, c='xkcd:rose', ls='dashed')            ax0.plot(ceph_north['R'], ceph_north['z'], c='xkcd:rose',lw=1,                     label='Stars (Chen 19)',ls='dashed')            ax0.plot(np.linspace(0,20,100), OneDwarp(np.linspace(0,20,100),popt[0],popt[1],popt[2],-90),                    lw=1, ls='solid', c='r',                     # label=r'$\Delta Z \propto Z_{20} (r-r_w)^{b}$'+'\n'+r'$Z_{20}$'+' = %.1f kpc, b=%.1f, '%(popt[0]*(20-popt[2])**popt[1],popt[1])+r'$r_w$'+'=%.1f kpc'%(popt[2]),                    label='Stars in Tilted Halo (Han 23)',                    alpha=1)                        ax1.plot(ceph_south['R'], ceph_south['z'], c='xkcd:rose',lw=1,ls='dashed')            ax1.plot(np.linspace(0,20,100), OneDwarp(np.linspace(0,20,100),popt[0],popt[1],popt[2],90),                    lw=1, ls='solid', c='r', label=r'$\Delta Z \propto Z_{20} (r-r_w)^{b}$'+'\n'+r'$Z_{20}$'+' = %.1f kpc, b=%.1f, '%(popt[0]*(20-popt[2])**popt[1],popt[1])+r'$r_w$'+'=%.1f kpc'%(popt[2]),                    alpha=1)                                dr= 4            r_bins = np.arange(0,20,0.1)            scales = []            for r in r_bins:                data = np.abs(deltaZ[(compute_R(w0[ind])>=r)&(compute_R(w0[ind])<=(r+dr))& (np.abs(deltaZ)<2)])                loc, scale = expon.fit(data)                scales.append(scale)            scales = np.array(scales)            im = ax2.scatter(compute_R(w0[ind]), deltaZ, s=0.1, c='k', alpha=0.2)            ax2.set_yticks([-0.5,0,0.5])            ax2.text(1, -0.8, 'Flare')            ax2.set_xlim([0,20])            ax2.set_ylim([-1.2,1.2])            ax2.set_ylabel(r'$|Z - Z_{warp}|$')            ax2.set_xlabel(r'$R$ [kpc]')            ax2.plot(r_bins, scales, lw=1, ls='-',c='r')            ax2.plot(r_bins, -scales, lw=1, ls='-',c='r')        ax0.scatter(compute_R(w0[ind][signs<0]),w0.z[ind][signs<0], s=.1, c='k',alpha=0.2)        ax0.set_xlim([0,20])        ax0.set_ylim([-0.7,2])        ax0.set_xticks([])        ax0.set_yticks([0,0.5,1,1.5])                ax0.set_ylabel(r'$Z$ [kpc]')        ax0.legend(loc='upper left', frameon=False)        ax0.text(1, -0.5, 'Northern Warp')        ax1.scatter(compute_R(w0[ind][signs>0]),w0.z[ind][signs>0], s=.1, c='k',alpha=0.2)        ax1.set_xlim([0,20])        ax1.set_ylim([-2,0.7])        ax1.set_xticks([])        ax1.set_yticks([-1.5,-1,-0.5,0])        ax1.set_ylabel(r'$Z$ [kpc]')        ax1.text(1, -1.5, 'Southern Warp')    plot_one('Stars')    plot_one('Gas')        plt.show()        passplot_lit_both(0, 5000)#%%def plot_rcat():    # line1 = lambda x: 0.27-0.5*(x+0.7)    # line2 = lambda x: 0.27-0.95*(x+0.7)    # line3 = lambda x: 0.27-0.1*(x+0.7)    with fits.open('/Users/jhan/Science/H3/catalogs/rcat_V4.0.5.d20221116_MSG.fits') as hdul:        mask = (hdul[1].data['flag']==0) & (hdul[1].data['coldstr']==0) &\                  (hdul[1].data['SNR']>3) &\                   (hdul[1].data['Lz']<0) & (hdul[1].data['logg']<3.5) &\                  (hdul[1].data['eccen_pot1']<0.1) &\                    (hdul[1].data['FeH']>-0.5) &\                    (hdul[1].data['aFe']<0.1)                  # ((hdul[1].data['afe'] > line1(hdul[1].data['feh']))&(hdul[1].data['afe'] > line3(hdul[1].data['feh']))) &\                  # (hdul[1].data['E_tot_pot1']<-1.2e5)                data = hdul[1].data[mask]        gc = coord.SkyCoord(x=data['X_gal']*u.kpc,                       y=data['Y_gal']*u.kpc,                       z=data['Z_gal']*u.kpc,                       frame=coord.Galactocentric)    gc = gc.transform_to(coord.Galactic)        # plt.figure(dpi=300,figsize=(6,5))    # ax = plt.gca()    # pm_z = ((data['Vz_gal']*u.km/u.s) *u.rad*np.cos(np.radians(gc.b)) / gc.distance).to(u.mas/u.year)    # im = ax.scatter(gc.l, pm_z, s=1, c=np.sqrt(data['X_gal']**2+data['Y_gal']**2),    #             cmap='cmr.torch_r',norm=clr.Normalize(0,40))    # # plt.ylim([-0.2,0.4])    # plt.xlim([0,360])    # plt.xlabel(r'$l(^\circ)$')    # plt.ylabel(r'$\mu_b$ [mas/yr]')    # im.set_clim(0,30)    # cbar = fig.colorbar(im, ax=ax)    # cbar.ax.get_yaxis().labelpad = 15    # cbar.ax.set_ylabel('R [kpc]', rotation=270)    # plt.show()        fig = plt.figure(dpi=300,figsize=(6,5))    ax = plt.gca()    ax.set_title('[a/Fe]<0.1, [Fe/H]>-0.5, e<0.3')    # im = ax.scatter(data['Y_gal'], data['Z_gal'], s=.1, c = data['FeH'],    #             cmap='bwr',norm=clr.Normalize(-0.5,1))    im = ax.scatter(Angle(data['l']*u.deg).wrap_at(180*u.deg), data['Vz_gal'], s=.1, c = data['FeH'],                cmap='jet',norm=clr.Normalize(-0.5,1))    # plt.xlim([-10,10])    # plt.ylim([-10,10])    plt.xlabel('Y_gal [kpc]')    plt.ylabel('Z_gal [kpc]')    # ax.set_xlim([20,-20])    # ax.set_ylim([-5,5])    im.set_clim(-0.5,1)    cbar = fig.colorbar(im, ax=ax)    cbar.ax.get_yaxis().labelpad = 15    cbar.ax.set_ylabel('[Fe/H]', rotation=270)    plt.show()        # plt.figure(dpi=300,figsize=(6,5))    # ax = plt.gca()    # im = ax.scatter(data['Lz'], data['E_tot_pot1'], s=1, c=np.sqrt(data['X_gal']**2+data['Y_gal']**2),    #             cmap='cmr.torch_r',norm=clr.Normalize(0,40))    # # plt.xlim([-10,10])    # # plt.ylim([-10,10])    # # plt.xlabel(r'$l(^\circ)$')    # # plt.ylabel(r'$\mu_b$ [mas/yr]')    # im.set_clim(0,30)    # cbar = fig.colorbar(im, ax=ax)    # cbar.ax.get_yaxis().labelpad = 15    # cbar.ax.set_ylabel('R [kpc]', rotation=270)    # plt.show()        pass# plot_rcat()#%%def plot_dr3():    with fits.open('/Users/jhan/Science/DR3/dr3-rv-good-plx-MilkyWayPotential2022-joined.fits') as hdul:        mask = (hdul[1].data['ecc']<0.1) & (hdul[1].data['has_rvs']==1)\            & (hdul[1].data['astrophysical_parameters_mh_gspphot']>-1)\                & (np.abs(hdul[1].data['xyz'][:,2])>0.5)            # & (hdul[1].data['xyz'][:,2]<5) & (np.sqrt(hdul[1].data['xyz'][:,0]**2+hdul[1].data['xyz'][:,1]**2)>5)        data = hdul[1].data[mask]    # plt.figure(dpi=300)    # plt.scatter(data['xyz'][:,0],data['xyz'][:,1],c=[data['vxyz'][:,2]],s=0.01,alpha=0.5,cmap='bwr',    #             norm=clr.Normalize(-10,10))    # # plt.hist(data['vxyz'][:,2],bins=200,histtype='step')    # plt.show()        # plt.figure(dpi=300,figsize=(6,5))    # ax = plt.gca()    # gc = coord.SkyCoord(x=data['xyz'][:,0]*u.kpc,    #                    y=data['xyz'][:,1]*u.kpc,    #                    z=data['xyz'][:,2]*u.kpc,    #                    frame=coord.Galactocentric)    # gc = gc.transform_to(coord.Galactic)    # pm_z = ((data['vxyz'][:,2]*u.km/u.s) *u.rad*np.cos(np.radians(gc.b)) / gc.distance).to(u.mas/u.year)    # im = ax.scatter(gc.l, pm_z, s=.1, c=np.sqrt(data['xyz'][:,0]**2+data['xyz'][:,1]**2),    #             cmap='cmr.torch_r',norm=clr.Normalize(0,20))    # # im = ax.hist2d(gc.l.degree, pm_z.value, bins=[np.linspace(0,360,200), np.linspace(-0.2,0.4,200)])    # plt.ylim([-1,1])    # plt.xlabel(r'$l(^\circ)$')    # plt.ylabel(r'$\mu_b$ [mas/yr]')    # # im.set_clim(0,30)    # # cbar = fig.colorbar(im, ax=ax)    # # cbar.ax.get_yaxis().labelpad = 15    # # cbar.ax.set_ylabel('R [kpc]', rotation=270)    # plt.show()        plt.figure(dpi=300,figsize=(6,5))    ax = plt.gca()    # ax.hist2d(data['xyz'][:,1], data['xyz'][:,2], bins=[np.linspace(-10,10,500), np.linspace(-2,2,500)],              # cmap='cmr.torch_r',norm=clr.LogNorm(),weights=np.abs(data['xyz'][:,1])*np.abs(data['xyz'][:,2])**2)        ax.hist2d(data['xyz'][:,1], data['vxyz'][:,2], bins=[np.linspace(-10,10,200), np.linspace(-50,50,200)],               cmap='cmr.torch_r',norm=clr.LogNorm(),weights=np.abs(data['xyz'][:,1]))        # H, xed, yed = np.histogram2d(data['xyz'][:,1], data['vxyz'][:,2], bins=[np.linspace(-10,10,200), np.linspace(-50,50,200)], density=False, weights=None)        plt.show()        pass# plot_dr3()#%%def track_ring( Ring, R_GSE, R_SFR): # ADD particles as we go!        nstep = 5000    tind = np.arange(nstep)    dt = 1.    pot_list = evolving_potential(dt,nstep,R_GSE)    Rscale_list = R_SFR*(1- ( 5000 - tind*dt) /8000 )    # Rscale_list = 6*np.ones(nstep)    # First, initialize conditions    agelist = []    nsample_final = 10000    nsample_init = int(nsample_final * (3/8))        nsample_add = int((nsample_final-nsample_init)/nstep)    print("Adding %d particles per timestep\n" %nsample_add)        w0 = initialize_Ring(nsample_init, pot_list[0], Ring)    for i in range(nsample_init):        agelist.append(dt*nstep)    wlist = [w0]    print("Beginning orbit int...\n")    for i, step in enumerate(range(nstep)):        # if i%100==0:        #     print(i)        pot = pot_list[i]        w0 = pot.integrate_orbit(w0, dt=dt*u.Myr, n_steps=1)[-1] # Integrate one step        w1 = initialize_realism(nsample_add, pot, Rscale_list[i])        # Now update w0 include newly spawned stars        w0 = gd.PhaseSpacePosition(pos=np.hstack([w0.pos.get_xyz(),w1.pos.get_xyz()]),                                   vel=np.hstack([w0.vel.get_d_xyz(),w1.vel.get_d_xyz()]))        birthRlist.extend(compute_R(w1))        for j in range(nsample_add):            agelist.append(dt*(nstep-step+1))        # w0 = churn_step(w0, dt, sigma=3.6) # Radial migration        wlist.append(w0)            return wlist, agelist# Ring_wlist, Ring_agelist = track_ring(15, R_GSE=30, R_SFR=6)#%%def plot_longwarp(wlist, step):    wstep = wlist[step]    inds = (np.array(Ring_agelist)>=4e3) & (np.array(Ring_agelist)<=5e3)    gc = coord.SkyCoord(x=wstep.x[inds],                       y=wstep.y[inds],                       z=wstep.z[inds],                       frame=coord.Galactocentric)    gc = gc.transform_to(coord.Galactic)        plt.figure(dpi=400,figsize=(6,4))    plt.scatter(Angle(gc.l).wrap_at(180*u.deg), wstep.z[inds],s=.1,                c=np.array(Ring_agelist)[inds], cmap='cmr.torch_r', norm=clr.Normalize(-1000,5000))    # plt.ylim([-2,2])    plt.gca().invert_xaxis()    plt.colorbar()    plt.show()        pass# plot_longwarp(Ring_wlist, -1)